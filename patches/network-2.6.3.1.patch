From d2c74f7ad32eff3de12757d0cbeba3b8cc6c0c31 Mon Sep 17 00:00:00 2001
From: Rahul Muttineni <rahulmutt@gmail.com>
Date: Sat, 28 Jan 2017 14:23:41 +0530
Subject: [PATCH] Patched

---
 Network/Socket.hs        | 1664 ++++++++++++++++++++++++++++++++++++++++++++++
 Network/Socket.hsc       | 1660 ---------------------------------------------
 Network/Socket/Types.hs  | 1104 ++++++++++++++++++++++++++++++
 Network/Socket/Types.hsc | 1103 ------------------------------
 java/Utils.java          |   15 +
 network.cabal            |   45 +-
 6 files changed, 2806 insertions(+), 2785 deletions(-)
 create mode 100644 Network/Socket.hs
 delete mode 100644 Network/Socket.hsc
 create mode 100644 Network/Socket/Types.hs
 delete mode 100644 Network/Socket/Types.hsc
 create mode 100644 java/Utils.java

diff --git a/Network/Socket.hs b/Network/Socket.hs
new file mode 100644
index 0000000..930edc0
--- /dev/null
+++ b/Network/Socket.hs
@@ -0,0 +1,1664 @@
+{-# LANGUAGE CPP, ScopedTypeVariables #-}
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+-----------------------------------------------------------------------------
+-- |
+-- Module      :  Network.Socket
+-- Copyright   :  (c) The University of Glasgow 2001
+-- License     :  BSD-style (see the file libraries/network/LICENSE)
+--
+-- Maintainer  :  libraries@haskell.org
+-- Stability   :  provisional
+-- Portability :  portable
+--
+-- The "Network.Socket" module is for when you want full control over
+-- sockets.  Essentially the entire C socket API is exposed through
+-- this module; in general the operations follow the behaviour of the C
+-- functions of the same name (consult your favourite Unix networking book).
+--
+-- A higher level interface to networking operations is provided
+-- through the module "Network".
+--
+-----------------------------------------------------------------------------
+
+-- #include "HsNet.h"
+
+-- In order to process this file, you need to have CALLCONV defined.
+
+module Network.Socket
+    (
+    -- * Types
+    --   Socket(..)
+    -- , Family(..)
+    -- , isSupportedFamily
+    -- , SocketType(..)
+    -- , isSupportedSocketType
+    -- ,
+    SockAddr(..)
+    -- , isSupportedSockAddr
+    -- , SocketStatus(..)
+    , HostAddress
+--     , hostAddressToTuple
+--     , tupleToHostAddress
+-- #if defined(IPV6_SOCKET_SUPPORT)
+    , HostAddress6
+    -- , hostAddress6ToTuple
+    -- , tupleToHostAddress6
+    , FlowInfo
+    , ScopeID
+-- #endif
+    -- , htonl
+    -- , ntohl
+    -- , ShutdownCmd(..)
+    -- , ProtocolNumber
+    -- , defaultProtocol
+    , PortNumber(..)
+    -- PortNumber is used non-abstractly in Network.BSD.  ToDo: remove
+    -- this use and make the type abstract.
+
+    -- * Address operations
+
+--     , HostName
+--     , ServiceName
+
+-- #if defined(IPV6_SOCKET_SUPPORT)
+--     , AddrInfo(..)
+
+--     , AddrInfoFlag(..)
+--     , addrInfoFlagImplemented
+
+--     , defaultHints
+
+--     , getAddrInfo
+
+--     , NameInfoFlag(..)
+
+--     , getNameInfo
+-- #endif
+
+--     -- * Socket operations
+--     , socket
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+--     , socketPair
+-- #endif
+--     , connect
+--     , bind
+--     , listen
+--     , accept
+--     , getPeerName
+--     , getSocketName
+
+-- #if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
+--     -- get the credentials of our domain socket peer.
+--     , getPeerCred
+-- #if defined(HAVE_GETPEEREID)
+--     , getPeerEid
+-- #endif
+-- #endif
+
+--     , socketPort
+
+--     , socketToHandle
+
+--     -- ** Sending and receiving data
+--     -- *** Sending and receiving with String
+--     -- $sendrecv
+--     , send
+--     , sendTo
+--     , recv
+--     , recvFrom
+--     , recvLen
+
+--     -- *** Sending and receiving with a buffer
+--     , sendBuf
+--     , recvBuf
+--     , sendBufTo
+--     , recvBufFrom
+
+--     -- ** Misc
+--     , inet_addr
+--     , inet_ntoa
+
+--     , shutdown
+--     , close
+
+--     -- ** Predicates on sockets
+--     , isConnected
+--     , isBound
+--     , isListening
+--     , isReadable
+--     , isWritable
+
+--     -- * Socket options
+--     , SocketOption(..)
+--     , isSupportedSocketOption
+--     , getSocketOption
+--     , setSocketOption
+
+--     -- * File descriptor transmission
+-- #ifdef DOMAIN_SOCKET_SUPPORT
+--     , sendFd
+--     , recvFd
+
+-- #endif
+
+--     -- * Special constants
+--     , aNY_PORT
+--     , iNADDR_ANY
+-- #if defined(IPV6_SOCKET_SUPPORT)
+--     , iN6ADDR_ANY
+-- #endif
+--     , sOMAXCONN
+--     , sOL_SOCKET
+-- #ifdef SCM_RIGHTS
+--     , sCM_RIGHTS
+-- #endif
+--     , maxListenQueue
+
+--     -- * Initialisation
+--     , withSocketsDo
+
+--     -- * Very low level operations
+--     -- in case you ever want to get at the underlying file descriptor..
+--     , fdSocket
+--     , mkSocket
+
+--     -- * Deprecated aliases
+--     -- $deprecated-aliases
+--     , bindSocket
+--     , sClose
+--     , sIsConnected
+--     , sIsBound
+--     , sIsListening
+--     , sIsReadable
+--     , sIsWritable
+
+--     -- * Internal
+
+--     -- | The following are exported ONLY for use in the BSD module and
+--     -- should not be used anywhere else.
+
+--     , packFamily
+--     , unpackFamily
+--     , packSocketType
+    ) where
+
+-- import Data.Bits
+-- import Data.Functor
+-- import Data.List (foldl')
+-- import Data.Maybe (isJust)
+-- import Data.Word (Word8, Word32)
+-- import Foreign.Ptr (Ptr, castPtr, nullPtr)
+-- import Foreign.Storable (Storable(..))
+-- import Foreign.C.Error
+-- import Foreign.C.String (CString, withCString, withCStringLen, peekCString, peekCStringLen)
+-- import Foreign.C.Types (CUInt, CChar)
+-- import Foreign.C.Types (CInt(..), CSize(..))
+-- import Foreign.Marshal.Alloc ( alloca, allocaBytes )
+-- import Foreign.Marshal.Array ( peekArray )
+-- import Foreign.Marshal.Utils ( maybeWith, with )
+
+-- import System.IO
+-- import Control.Monad (liftM, when)
+
+-- import Control.Concurrent.MVar
+-- import Data.Typeable
+-- import System.IO.Error
+
+-- import GHC.Conc (threadWaitRead, threadWaitWrite)
+-- ##if MIN_VERSION_base(4,3,1)
+-- import GHC.Conc (closeFdWith)
+-- ##endif
+-- # if defined(mingw32_HOST_OS)
+-- import qualified Control.Exception as E
+-- import GHC.Conc (asyncDoProc)
+-- import GHC.IO.FD (FD(..), readRawBufferPtr, writeRawBufferPtr)
+-- import Foreign (FunPtr)
+-- # endif
+-- # if defined(darwin_HOST_OS)
+-- import Data.List (delete)
+-- # endif
+-- import qualified GHC.IO.Device
+-- import GHC.IO.Handle.FD
+-- import GHC.IO.Exception
+-- import GHC.IO
+-- import qualified System.Posix.Internals
+
+-- import Network.Socket.Internal
+import Network.Socket.Types
+
+-- import Prelude -- Silence AMP warnings
+
+-- | Either a host name e.g., @\"haskell.org\"@ or a numeric host
+-- address string consisting of a dotted decimal IPv4 address or an
+-- IPv6 address e.g., @\"192.168.0.1\"@.
+-- type HostName       = String
+-- type ServiceName    = String
+
+-- ----------------------------------------------------------------------------
+-- On Windows, our sockets are not put in non-blocking mode (non-blocking
+-- is not supported for regular file descriptors on Windows, and it would
+-- be a pain to support it only for sockets).  So there are two cases:
+--
+--  - the threaded RTS uses safe calls for socket operations to get
+--    non-blocking I/O, just like the rest of the I/O library
+--
+--  - with the non-threaded RTS, only some operations on sockets will be
+--    non-blocking.  Reads and writes go through the normal async I/O
+--    system.  accept() uses asyncDoProc so is non-blocking.  A handful
+--    of others (recvFrom, sendFd, recvFd) will block all threads - if this
+--    is a problem, -threaded is the workaround.
+--
+-- ##if defined(mingw32_HOST_OS)
+-- ##define SAFE_ON_WIN safe
+-- ##else
+-- ##define SAFE_ON_WIN unsafe
+-- ##endif
+
+-----------------------------------------------------------------------------
+-- Socket types
+
+-- #if defined(mingw32_HOST_OS)
+-- socket2FD  (MkSocket fd _ _ _ _) =
+--   -- HACK, 1 means True
+--   FD{fdFD = fd,fdIsSocket_ = 1}
+-- #endif
+
+-- mkSocket :: CInt
+--          -> Family
+--          -> SocketType
+--          -> ProtocolNumber
+--          -> SocketStatus
+--          -> IO Socket
+-- mkSocket fd fam sType pNum stat = do
+--    mStat <- newMVar stat
+--    withSocketsDo $ return ()
+--    return (MkSocket fd fam sType pNum mStat)
+
+
+-- fdSocket :: Socket -> CInt
+-- fdSocket (MkSocket fd _ _ _ _) = fd
+
+-- -- | This is the default protocol for a given service.
+-- defaultProtocol :: ProtocolNumber
+-- defaultProtocol = 0
+
+-----------------------------------------------------------------------------
+-- SockAddr
+
+instance Show SockAddr where
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+  showsPrec _ (SockAddrUnix str) = showString str
+-- #endif
+  showsPrec _ (SockAddrInet port ha)
+   = showString (inet_ntoa ha)
+   . showString ":"
+   . shows port
+-- #if defined(IPV6_SOCKET_SUPPORT)
+--   showsPrec _ addr@(SockAddrInet6 port _ _ _)
+--    = showChar '['
+--    . showString (unsafePerformIO $
+--                  fst `liftM` getNameInfo [NI_NUMERICHOST] True False addr >>=
+--                  maybe (fail "showsPrec: impossible internal error") return)
+--    . showString "]:"
+--    . shows port
+-- #endif
+-- #if defined(CAN_SOCKET_SUPPORT)
+  showsPrec _ (SockAddrCan ifidx) = shows ifidx
+-- #endif
+
+foreign import java unsafe "@static eta.network.Utils.inet_ntoa" inet_ntoa ::
+  HostAddress -> String
+
+-----------------------------------------------------------------------------
+-- Connection Functions
+
+-- In the following connection and binding primitives.  The names of
+-- the equivalent C functions have been preserved where possible. It
+-- should be noted that some of these names used in the C library,
+-- \tr{bind} in particular, have a different meaning to many Haskell
+-- programmers and have thus been renamed by appending the prefix
+-- Socket.
+
+-- | Create a new socket using the given address family, socket type
+-- and protocol number.  The address family is usually 'AF_INET',
+-- 'AF_INET6', or 'AF_UNIX'.  The socket type is usually 'Stream' or
+-- 'Datagram'.  The protocol number is usually 'defaultProtocol'.
+-- If 'AF_INET6' is used and the socket type is 'Stream' or 'Datagram',
+-- the 'IPv6Only' socket option is set to 0 so that both IPv4 and IPv6
+-- can be handled with one socket.
+--
+-- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
+-- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
+-- >>> sock@(MkSocket _ fam stype _ _) <- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
+-- >>> fam
+-- AF_INET
+-- >>> stype
+-- Stream
+-- >>> bind sock (addrAddress addr)
+-- >>> getSocketName sock
+-- 127.0.0.1:5000
+-- socket :: Family         -- Family Name (usually AF_INET)
+--        -> SocketType     -- Socket Type (usually Stream)
+--        -> ProtocolNumber -- Protocol Number (getProtocolByName to find value)
+--        -> IO Socket      -- Unconnected Socket
+-- socket family stype protocol = do
+--     c_stype <- packSocketTypeOrThrow "socket" stype
+--     fd <- throwSocketErrorIfMinus1Retry "socket" $
+--                 c_socket (packFamily family) c_stype protocol
+--     setNonBlockIfNeeded fd
+--     socket_status <- newMVar NotConnected
+--     withSocketsDo $ return ()
+--     let sock = MkSocket fd family stype protocol socket_status
+-- #if HAVE_DECL_IPV6_V6ONLY
+--     -- The default value of the IPv6Only option is platform specific,
+--     -- so we explicitly set it to 0 to provide a common default.
+-- # if defined(mingw32_HOST_OS)
+--     -- The IPv6Only option is only supported on Windows Vista and later,
+--     -- so trying to change it might throw an error.
+--     when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
+--       E.catch (setSocketOption sock IPv6Only 0) $ (\(_ :: E.IOException) -> return ())
+-- # else
+--     when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
+--       setSocketOption sock IPv6Only 0 `onException` close sock
+-- # endif
+-- #endif
+--     return sock
+
+-- -- | Build a pair of connected socket objects using the given address
+-- -- family, socket type, and protocol number.  Address family, socket
+-- -- type, and protocol number are as for the 'socket' function above.
+-- -- Availability: Unix.
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+-- socketPair :: Family              -- Family Name (usually AF_INET or AF_INET6)
+--            -> SocketType          -- Socket Type (usually Stream)
+--            -> ProtocolNumber      -- Protocol Number
+--            -> IO (Socket, Socket) -- unnamed and connected.
+-- socketPair family stype protocol = do
+--     allocaBytes (2 * sizeOf (1 :: CInt)) $ \ fdArr -> do
+--     c_stype <- packSocketTypeOrThrow "socketPair" stype
+--     _rc <- throwSocketErrorIfMinus1Retry "socketpair" $
+--                 c_socketpair (packFamily family) c_stype protocol fdArr
+--     [fd1,fd2] <- peekArray 2 fdArr
+--     s1 <- mkNonBlockingSocket fd1
+--     s2 <- mkNonBlockingSocket fd2
+--     return (s1,s2)
+--   where
+--     mkNonBlockingSocket fd = do
+--        setNonBlockIfNeeded fd
+--        stat <- newMVar Connected
+--        withSocketsDo $ return ()
+--        return (MkSocket fd family stype protocol stat)
+
+-- foreign import ccall unsafe "socketpair"
+--   c_socketpair :: CInt -> CInt -> CInt -> Ptr CInt -> IO CInt
+-- #endif
+
+-- -- | Set the socket to nonblocking, if applicable to this platform.
+-- setNonBlockIfNeeded :: CInt -> IO ()
+-- setNonBlockIfNeeded fd =
+--     System.Posix.Internals.setNonBlockingFD fd True
+
+-- -----------------------------------------------------------------------------
+-- -- Binding a socket
+
+-- -- | Bind the socket to an address. The socket must not already be
+-- -- bound.  The 'Family' passed to @bind@ must be the
+-- -- same as that passed to 'socket'.  If the special port number
+-- -- 'aNY_PORT' is passed then the system assigns the next available
+-- -- use port.
+-- bind :: Socket    -- Unconnected Socket
+--            -> SockAddr  -- Address to Bind to
+--            -> IO ()
+-- bind (MkSocket s _family _stype _protocol socketStatus) addr = do
+--  modifyMVar_ socketStatus $ \ status -> do
+--  if status /= NotConnected
+--   then
+--    ioError (userError ("bind: can't peform bind on socket in status " ++
+--          show status))
+--   else do
+--    withSockAddr addr $ \p_addr sz -> do
+--    _status <- throwSocketErrorIfMinus1Retry "bind" $ c_bind s p_addr (fromIntegral sz)
+--    return Bound
+
+-- -----------------------------------------------------------------------------
+-- -- Connecting a socket
+
+-- -- | Connect to a remote socket at address.
+-- connect :: Socket    -- Unconnected Socket
+--         -> SockAddr  -- Socket address stuff
+--         -> IO ()
+-- connect sock@(MkSocket s _family _stype _protocol socketStatus) addr = withSocketsDo $ do
+--  modifyMVar_ socketStatus $ \currentStatus -> do
+--  if currentStatus /= NotConnected && currentStatus /= Bound
+--   then
+--     ioError (userError ("connect: can't peform connect on socket in status " ++
+--         show currentStatus))
+--   else do
+--     withSockAddr addr $ \p_addr sz -> do
+
+--     let connectLoop = do
+--            r <- c_connect s p_addr (fromIntegral sz)
+--            if r == -1
+--                then do
+-- #if !(defined(HAVE_WINSOCK2_H))
+--                    err <- getErrno
+--                    case () of
+--                      _ | err == eINTR       -> connectLoop
+--                      _ | err == eINPROGRESS -> connectBlocked
+-- --                   _ | err == eAGAIN      -> connectBlocked
+--                      _otherwise             -> throwSocketError "connect"
+-- #else
+--                    throwSocketError "connect"
+-- #endif
+--                else return ()
+
+--         connectBlocked = do
+--            threadWaitWrite (fromIntegral s)
+--            err <- getSocketOption sock SoError
+--            if (err == 0)
+--                 then return ()
+--                 else throwSocketErrorCode "connect" (fromIntegral err)
+
+--     connectLoop
+--     return Connected
+
+-- -----------------------------------------------------------------------------
+-- -- Listen
+
+-- -- | Listen for connections made to the socket.  The second argument
+-- -- specifies the maximum number of queued connections and should be at
+-- -- least 1; the maximum value is system-dependent (usually 5).
+-- listen :: Socket  -- Connected & Bound Socket
+--        -> Int     -- Queue Length
+--        -> IO ()
+-- listen (MkSocket s _family _stype _protocol socketStatus) backlog = do
+--  modifyMVar_ socketStatus $ \ status -> do
+--  if status /= Bound
+--    then
+--      ioError (userError ("listen: can't peform listen on socket in status " ++
+--          show status))
+--    else do
+--      throwSocketErrorIfMinus1Retry_ "listen" (c_listen s (fromIntegral backlog))
+--      return Listening
+
+-- -----------------------------------------------------------------------------
+-- -- Accept
+-- --
+-- -- A call to `accept' only returns when data is available on the given
+-- -- socket, unless the socket has been set to non-blocking.  It will
+-- -- return a new socket which should be used to read the incoming data and
+-- -- should then be closed. Using the socket returned by `accept' allows
+-- -- incoming requests to be queued on the original socket.
+
+-- -- | Accept a connection.  The socket must be bound to an address and
+-- -- listening for connections.  The return value is a pair @(conn,
+-- -- address)@ where @conn@ is a new socket object usable to send and
+-- -- receive data on the connection, and @address@ is the address bound
+-- -- to the socket on the other end of the connection.
+-- accept :: Socket                        -- Queue Socket
+--        -> IO (Socket,                   -- Readable Socket
+--               SockAddr)                 -- Peer details
+
+-- accept sock@(MkSocket s family stype protocol status) = do
+--  currentStatus <- readMVar status
+--  okay <- isAcceptable sock
+--  if not okay
+--    then
+--      ioError (userError ("accept: can't perform accept on socket (" ++ (show (family,stype,protocol)) ++") in status " ++
+--          show currentStatus))
+--    else do
+--      let sz = sizeOfSockAddrByFamily family
+--      allocaBytes sz $ \ sockaddr -> do
+-- #if defined(mingw32_HOST_OS)
+--      new_sock <-
+--         if threaded
+--            then with (fromIntegral sz) $ \ ptr_len ->
+--                   throwSocketErrorIfMinus1Retry "Network.Socket.accept" $
+--                     c_accept_safe s sockaddr ptr_len
+--            else do
+--                 paramData <- c_newAcceptParams s (fromIntegral sz) sockaddr
+--                 rc        <- asyncDoProc c_acceptDoProc paramData
+--                 new_sock  <- c_acceptNewSock    paramData
+--                 c_free paramData
+--                 when (rc /= 0) $
+--                      throwSocketErrorCode "Network.Socket.accept" (fromIntegral rc)
+--                 return new_sock
+-- #else
+--      with (fromIntegral sz) $ \ ptr_len -> do
+-- # ifdef HAVE_ACCEPT4
+--      new_sock <- throwSocketErrorIfMinus1RetryMayBlock "accept"
+--                         (threadWaitRead (fromIntegral s))
+--                         (c_accept4 s sockaddr ptr_len (#const SOCK_NONBLOCK))
+-- # else
+--      new_sock <- throwSocketErrorWaitRead sock "accept"
+--                         (c_accept s sockaddr ptr_len)
+--      setNonBlockIfNeeded new_sock
+-- # endif /* HAVE_ACCEPT4 */
+-- #endif
+--      addr <- peekSockAddr sockaddr
+--      new_status <- newMVar Connected
+--      return ((MkSocket new_sock family stype protocol new_status), addr)
+
+-- #if defined(mingw32_HOST_OS)
+-- foreign import ccall unsafe "HsNet.h acceptNewSock"
+--   c_acceptNewSock :: Ptr () -> IO CInt
+-- foreign import ccall unsafe "HsNet.h newAcceptParams"
+--   c_newAcceptParams :: CInt -> CInt -> Ptr a -> IO (Ptr ())
+-- foreign import ccall unsafe "HsNet.h &acceptDoProc"
+--   c_acceptDoProc :: FunPtr (Ptr () -> IO Int)
+-- foreign import ccall unsafe "free"
+--   c_free:: Ptr a -> IO ()
+-- #endif
+
+-- -----------------------------------------------------------------------------
+-- -- ** Sending and reciving data
+
+-- -- $sendrecv
+-- --
+-- -- Do not use the @send@ and @recv@ functions defined in this section
+-- -- in new code, as they incorrectly represent binary data as a Unicode
+-- -- string.  As a result, these functions are inefficient and may lead
+-- -- to bugs in the program.  Instead use the @send@ and @recv@
+-- -- functions defined in the "Network.Socket.ByteString" module.
+
+-- -----------------------------------------------------------------------------
+-- -- sendTo & recvFrom
+
+-- -- | Send data to the socket.  The recipient can be specified
+-- -- explicitly, so the socket need not be in a connected state.
+-- -- Returns the number of bytes sent.  Applications are responsible for
+-- -- ensuring that all data has been sent.
+-- --
+-- -- NOTE: blocking on Windows unless you compile with -threaded (see
+-- -- GHC ticket #1129)
+-- {-# WARNING sendTo "Use sendTo defined in \"Network.Socket.ByteString\"" #-}
+-- sendTo :: Socket        -- (possibly) bound/connected Socket
+--        -> String        -- Data to send
+--        -> SockAddr
+--        -> IO Int        -- Number of Bytes sent
+-- sendTo sock xs addr = do
+--  withCStringLen xs $ \(str, len) -> do
+--    sendBufTo sock str len addr
+
+-- -- | Send data to the socket.  The recipient can be specified
+-- -- explicitly, so the socket need not be in a connected state.
+-- -- Returns the number of bytes sent.  Applications are responsible for
+-- -- ensuring that all data has been sent.
+-- sendBufTo :: Socket            -- (possibly) bound/connected Socket
+--           -> Ptr a -> Int  -- Data to send
+--           -> SockAddr
+--           -> IO Int            -- Number of Bytes sent
+-- sendBufTo sock@(MkSocket s _family _stype _protocol _status) ptr nbytes addr = do
+--  withSockAddr addr $ \p_addr sz -> do
+--    liftM fromIntegral $
+--      throwSocketErrorWaitWrite sock "sendTo" $
+--         c_sendto s ptr (fromIntegral $ nbytes) 0{-flags-}
+--                         p_addr (fromIntegral sz)
+
+-- -- | Receive data from the socket. The socket need not be in a
+-- -- connected state. Returns @(bytes, nbytes, address)@ where @bytes@
+-- -- is a @String@ of length @nbytes@ representing the data received and
+-- -- @address@ is a 'SockAddr' representing the address of the sending
+-- -- socket.
+-- --
+-- -- NOTE: blocking on Windows unless you compile with -threaded (see
+-- -- GHC ticket #1129)
+-- {-# WARNING recvFrom "Use recvFrom defined in \"Network.Socket.ByteString\"" #-}
+-- recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)
+-- recvFrom sock nbytes =
+--   allocaBytes nbytes $ \ptr -> do
+--     (len, sockaddr) <- recvBufFrom sock ptr nbytes
+--     str <- peekCStringLen (ptr, len)
+--     return (str, len, sockaddr)
+
+-- -- | Receive data from the socket, writing it into buffer instead of
+-- -- creating a new string.  The socket need not be in a connected
+-- -- state. Returns @(nbytes, address)@ where @nbytes@ is the number of
+-- -- bytes received and @address@ is a 'SockAddr' representing the
+-- -- address of the sending socket.
+-- --
+-- -- NOTE: blocking on Windows unless you compile with -threaded (see
+-- -- GHC ticket #1129)
+-- recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
+-- recvBufFrom sock@(MkSocket s family _stype _protocol _status) ptr nbytes
+--  | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvFrom")
+--  | otherwise   =
+--     withNewSockAddr family $ \ptr_addr sz -> do
+--       alloca $ \ptr_len -> do
+--         poke ptr_len (fromIntegral sz)
+--         len <- throwSocketErrorWaitRead sock "recvFrom" $
+--                    c_recvfrom s ptr (fromIntegral nbytes) 0{-flags-}
+--                                 ptr_addr ptr_len
+--         let len' = fromIntegral len
+--         if len' == 0
+--          then ioError (mkEOFError "Network.Socket.recvFrom")
+--          else do
+--            flg <- isConnected sock
+--              -- For at least one implementation (WinSock 2), recvfrom() ignores
+--              -- filling in the sockaddr for connected TCP sockets. Cope with
+--              -- this by using getPeerName instead.
+--            sockaddr <-
+--                 if flg then
+--                    getPeerName sock
+--                 else
+--                    peekSockAddr ptr_addr
+--            return (len', sockaddr)
+
+-- -----------------------------------------------------------------------------
+-- -- send & recv
+
+-- -- | Send data to the socket. The socket must be connected to a remote
+-- -- socket. Returns the number of bytes sent.  Applications are
+-- -- responsible for ensuring that all data has been sent.
+-- --
+-- -- Sending data to closed socket may lead to undefined behaviour.
+-- {-# WARNING send "Use send defined in \"Network.Socket.ByteString\"" #-}
+-- send :: Socket  -- Bound/Connected Socket
+--      -> String  -- Data to send
+--      -> IO Int  -- Number of Bytes sent
+-- send sock xs = withCStringLen xs $ \(str, len) ->
+--     sendBuf sock (castPtr str) len
+
+-- -- | Send data to the socket. The socket must be connected to a remote
+-- -- socket. Returns the number of bytes sent.  Applications are
+-- -- responsible for ensuring that all data has been sent.
+-- --
+-- -- Sending data to closed socket may lead to undefined behaviour.
+-- sendBuf :: Socket     -- Bound/Connected Socket
+--         -> Ptr Word8  -- Pointer to the data to send
+--         -> Int        -- Length of the buffer
+--         -> IO Int     -- Number of Bytes sent
+-- sendBuf sock@(MkSocket s _family _stype _protocol _status) str len = do
+--    liftM fromIntegral $
+-- #if defined(mingw32_HOST_OS)
+-- -- writeRawBufferPtr is supposed to handle checking for errors, but it's broken
+-- -- on x86_64 because of GHC bug #12010 so we duplicate the check here. The call
+-- -- to throwSocketErrorIfMinus1Retry can be removed when no GHC version with the
+-- -- bug is supported.
+--     throwSocketErrorIfMinus1Retry "Network.Socket.sendBuf" $ writeRawBufferPtr
+--       "Network.Socket.sendBuf"
+--       (socket2FD sock)
+--       (castPtr str)
+--       0
+--       (fromIntegral len)
+-- #else
+--      throwSocketErrorWaitWrite sock "sendBuf" $
+--         c_send s str (fromIntegral len) 0{-flags-}
+-- #endif
+
+
+-- -- | Receive data from the socket.  The socket must be in a connected
+-- -- state. This function may return fewer bytes than specified.  If the
+-- -- message is longer than the specified length, it may be discarded
+-- -- depending on the type of socket.  This function may block until a
+-- -- message arrives.
+-- --
+-- -- Considering hardware and network realities, the maximum number of
+-- -- bytes to receive should be a small power of 2, e.g., 4096.
+-- --
+-- -- For TCP sockets, a zero length return value means the peer has
+-- -- closed its half side of the connection.
+-- --
+-- -- Receiving data from closed socket may lead to undefined behaviour.
+-- {-# WARNING recv "Use recv defined in \"Network.Socket.ByteString\"" #-}
+-- recv :: Socket -> Int -> IO String
+-- recv sock l = fst <$> recvLen sock l
+
+-- {-# WARNING recvLen "Use recvLen defined in \"Network.Socket.ByteString\"" #-}
+-- recvLen :: Socket -> Int -> IO (String, Int)
+-- recvLen sock nbytes =
+--      allocaBytes nbytes $ \ptr -> do
+--         len <- recvBuf sock ptr nbytes
+--         s <- peekCStringLen (castPtr ptr,len)
+--         return (s, len)
+
+-- -- | Receive data from the socket.  The socket must be in a connected
+-- -- state. This function may return fewer bytes than specified.  If the
+-- -- message is longer than the specified length, it may be discarded
+-- -- depending on the type of socket.  This function may block until a
+-- -- message arrives.
+-- --
+-- -- Considering hardware and network realities, the maximum number of
+-- -- bytes to receive should be a small power of 2, e.g., 4096.
+-- --
+-- -- For TCP sockets, a zero length return value means the peer has
+-- -- closed its half side of the connection.
+-- --
+-- -- Receiving data from closed socket may lead to undefined behaviour.
+-- recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int
+-- recvBuf sock@(MkSocket s _family _stype _protocol _status) ptr nbytes
+--  | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvBuf")
+--  | otherwise   = do
+--         len <-
+-- #if defined(mingw32_HOST_OS)
+-- -- see comment in sendBuf above.
+--             throwSocketErrorIfMinus1Retry "Network.Socket.recvBuf" $
+--                 readRawBufferPtr "Network.Socket.recvBuf"
+--                 (socket2FD sock) ptr 0 (fromIntegral nbytes)
+-- #else
+--                throwSocketErrorWaitRead sock "recvBuf" $
+--                    c_recv s (castPtr ptr) (fromIntegral nbytes) 0{-flags-}
+-- #endif
+--         let len' = fromIntegral len
+--         if len' == 0
+--          then ioError (mkEOFError "Network.Socket.recvBuf")
+--          else return len'
+
+
+-- -- ---------------------------------------------------------------------------
+-- -- socketPort
+-- --
+-- -- The port number the given socket is currently connected to can be
+-- -- determined by calling $port$, is generally only useful when bind
+-- -- was given $aNY\_PORT$.
+
+-- socketPort :: Socket            -- Connected & Bound Socket
+--            -> IO PortNumber     -- Port Number of Socket
+-- socketPort sock@(MkSocket _ AF_INET _ _ _) = do
+--     (SockAddrInet port _) <- getSocketName sock
+--     return port
+-- #if defined(IPV6_SOCKET_SUPPORT)
+-- socketPort sock@(MkSocket _ AF_INET6 _ _ _) = do
+--     (SockAddrInet6 port _ _ _) <- getSocketName sock
+--     return port
+-- #endif
+-- socketPort (MkSocket _ family _ _ _) =
+--     ioError (userError ("socketPort: not supported for Family " ++ show family))
+
+
+-- -- ---------------------------------------------------------------------------
+-- -- getPeerName
+
+-- -- Calling $getPeerName$ returns the address details of the machine,
+-- -- other than the local one, which is connected to the socket. This is
+-- -- used in programs such as FTP to determine where to send the
+-- -- returning data.  The corresponding call to get the details of the
+-- -- local machine is $getSocketName$.
+
+-- getPeerName   :: Socket -> IO SockAddr
+-- getPeerName (MkSocket s family _ _ _) = do
+--  withNewSockAddr family $ \ptr sz -> do
+--    with (fromIntegral sz) $ \int_star -> do
+--    throwSocketErrorIfMinus1Retry_ "getPeerName" $ c_getpeername s ptr int_star
+--    _sz <- peek int_star
+--    peekSockAddr ptr
+
+-- getSocketName :: Socket -> IO SockAddr
+-- getSocketName (MkSocket s family _ _ _) = do
+--  withNewSockAddr family $ \ptr sz -> do
+--    with (fromIntegral sz) $ \int_star -> do
+--    throwSocketErrorIfMinus1Retry_ "getSocketName" $ c_getsockname s ptr int_star
+--    peekSockAddr ptr
+
+-- -----------------------------------------------------------------------------
+-- -- Socket Properties
+
+-- -- | Socket options for use with 'setSocketOption' and 'getSocketOption'.
+-- --
+-- -- The existence of a constructor does not imply that the relevant option
+-- -- is supported on your system: see 'isSupportedSocketOption'
+-- data SocketOption
+--     = Debug         -- ^ SO_DEBUG
+--     | ReuseAddr     -- ^ SO_REUSEADDR
+--     | Type          -- ^ SO_TYPE
+--     | SoError       -- ^ SO_ERROR
+--     | DontRoute     -- ^ SO_DONTROUTE
+--     | Broadcast     -- ^ SO_BROADCAST
+--     | SendBuffer    -- ^ SO_SNDBUF
+--     | RecvBuffer    -- ^ SO_RCVBUF
+--     | KeepAlive     -- ^ SO_KEEPALIVE
+--     | OOBInline     -- ^ SO_OOBINLINE
+--     | TimeToLive    -- ^ IP_TTL
+--     | MaxSegment    -- ^ TCP_MAXSEG
+--     | NoDelay       -- ^ TCP_NODELAY
+--     | Cork          -- ^ TCP_CORK
+--     | Linger        -- ^ SO_LINGER
+--     | ReusePort     -- ^ SO_REUSEPORT
+--     | RecvLowWater  -- ^ SO_RCVLOWAT
+--     | SendLowWater  -- ^ SO_SNDLOWAT
+--     | RecvTimeOut   -- ^ SO_RCVTIMEO
+--     | SendTimeOut   -- ^ SO_SNDTIMEO
+--     | UseLoopBack   -- ^ SO_USELOOPBACK
+--     | UserTimeout   -- ^ TCP_USER_TIMEOUT
+--     | IPv6Only      -- ^ IPV6_V6ONLY
+--     | CustomSockOpt (CInt, CInt)
+--     deriving (Show, Typeable)
+
+-- -- | Does the 'SocketOption' exist on this system?
+-- isSupportedSocketOption :: SocketOption -> Bool
+-- isSupportedSocketOption = isJust . packSocketOption
+
+-- -- | For a socket option, return Just (level, value) where level is the
+-- -- corresponding C option level constant (e.g. SOL_SOCKET) and value is
+-- -- the option constant itself (e.g. SO_DEBUG)
+-- -- If either constant does not exist, return Nothing.
+-- packSocketOption :: SocketOption -> Maybe (CInt, CInt)
+-- packSocketOption so =
+--   -- The Just here is a hack to disable GHC's overlapping pattern detection:
+--   -- the problem is if all constants are present, the fallback pattern is
+--   -- redundant, but if they aren't then it isn't. Hence we introduce an
+--   -- extra pattern (Nothing) that can't possibly happen, so that the
+--   -- fallback is always (in principle) necessary.
+--   -- I feel a little bad for including this, but such are the sacrifices we
+--   -- make while working with CPP - excluding the fallback pattern correctly
+--   -- would be a serious nuisance.
+--   -- (NB: comments elsewhere in this file refer to this one)
+--   case Just so of
+-- #ifdef SOL_SOCKET
+-- #ifdef SO_DEBUG
+--     Just Debug         -> Just ((#const SOL_SOCKET), (#const SO_DEBUG))
+-- #endif
+-- #ifdef SO_REUSEADDR
+--     Just ReuseAddr     -> Just ((#const SOL_SOCKET), (#const SO_REUSEADDR))
+-- #endif
+-- #ifdef SO_TYPE
+--     Just Type          -> Just ((#const SOL_SOCKET), (#const SO_TYPE))
+-- #endif
+-- #ifdef SO_ERROR
+--     Just SoError       -> Just ((#const SOL_SOCKET), (#const SO_ERROR))
+-- #endif
+-- #ifdef SO_DONTROUTE
+--     Just DontRoute     -> Just ((#const SOL_SOCKET), (#const SO_DONTROUTE))
+-- #endif
+-- #ifdef SO_BROADCAST
+--     Just Broadcast     -> Just ((#const SOL_SOCKET), (#const SO_BROADCAST))
+-- #endif
+-- #ifdef SO_SNDBUF
+--     Just SendBuffer    -> Just ((#const SOL_SOCKET), (#const SO_SNDBUF))
+-- #endif
+-- #ifdef SO_RCVBUF
+--     Just RecvBuffer    -> Just ((#const SOL_SOCKET), (#const SO_RCVBUF))
+-- #endif
+-- #ifdef SO_KEEPALIVE
+--     Just KeepAlive     -> Just ((#const SOL_SOCKET), (#const SO_KEEPALIVE))
+-- #endif
+-- #ifdef SO_OOBINLINE
+--     Just OOBInline     -> Just ((#const SOL_SOCKET), (#const SO_OOBINLINE))
+-- #endif
+-- #ifdef SO_LINGER
+--     Just Linger        -> Just ((#const SOL_SOCKET), (#const SO_LINGER))
+-- #endif
+-- #ifdef SO_REUSEPORT
+--     Just ReusePort     -> Just ((#const SOL_SOCKET), (#const SO_REUSEPORT))
+-- #endif
+-- #ifdef SO_RCVLOWAT
+--     Just RecvLowWater  -> Just ((#const SOL_SOCKET), (#const SO_RCVLOWAT))
+-- #endif
+-- #ifdef SO_SNDLOWAT
+--     Just SendLowWater  -> Just ((#const SOL_SOCKET), (#const SO_SNDLOWAT))
+-- #endif
+-- #ifdef SO_RCVTIMEO
+--     Just RecvTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_RCVTIMEO))
+-- #endif
+-- #ifdef SO_SNDTIMEO
+--     Just SendTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_SNDTIMEO))
+-- #endif
+-- #ifdef SO_USELOOPBACK
+--     Just UseLoopBack   -> Just ((#const SOL_SOCKET), (#const SO_USELOOPBACK))
+-- #endif
+-- #endif // SOL_SOCKET
+-- #if HAVE_DECL_IPPROTO_IP
+-- #ifdef IP_TTL
+--     Just TimeToLive    -> Just ((#const IPPROTO_IP), (#const IP_TTL))
+-- #endif
+-- #endif // HAVE_DECL_IPPROTO_IP
+-- #if HAVE_DECL_IPPROTO_TCP
+-- #ifdef TCP_MAXSEG
+--     Just MaxSegment    -> Just ((#const IPPROTO_TCP), (#const TCP_MAXSEG))
+-- #endif
+-- #ifdef TCP_NODELAY
+--     Just NoDelay       -> Just ((#const IPPROTO_TCP), (#const TCP_NODELAY))
+-- #endif
+-- #ifdef TCP_USER_TIMEOUT
+--     Just UserTimeout   -> Just ((#const IPPROTO_TCP), (#const TCP_USER_TIMEOUT))
+-- #endif
+-- #ifdef TCP_CORK
+--     Just Cork          -> Just ((#const IPPROTO_TCP), (#const TCP_CORK))
+-- #endif
+-- #endif // HAVE_DECL_IPPROTO_TCP
+-- #if HAVE_DECL_IPPROTO_IPV6
+-- #if HAVE_DECL_IPV6_V6ONLY
+--     Just IPv6Only      -> Just ((#const IPPROTO_IPV6), (#const IPV6_V6ONLY))
+-- #endif
+-- #endif // HAVE_DECL_IPPROTO_IPV6
+--     Just (CustomSockOpt opt) -> Just opt
+--     _             -> Nothing
+
+-- -- | Return the option level and option value if they exist,
+-- -- otherwise throw an error that begins "Network.Socket." ++ the String
+-- -- parameter
+-- packSocketOption' :: String -> SocketOption -> IO (CInt, CInt)
+-- packSocketOption' caller so = maybe err return (packSocketOption so)
+--  where
+--   err = ioError . userError . concat $ ["Network.Socket.", caller,
+--     ": socket option ", show so, " unsupported on this system"]
+
+-- -- | Set a socket option that expects an Int value.
+-- -- There is currently no API to set e.g. the timeval socket options
+-- setSocketOption :: Socket
+--                 -> SocketOption -- Option Name
+--                 -> Int          -- Option Value
+--                 -> IO ()
+-- setSocketOption (MkSocket s _ _ _ _) so v = do
+--    (level, opt) <- packSocketOption' "setSocketOption" so
+--    with (fromIntegral v) $ \ptr_v -> do
+--    throwSocketErrorIfMinus1_ "setSocketOption" $
+--        c_setsockopt s level opt ptr_v
+--           (fromIntegral (sizeOf (undefined :: CInt)))
+--    return ()
+
+
+-- -- | Get a socket option that gives an Int value.
+-- -- There is currently no API to get e.g. the timeval socket options
+-- getSocketOption :: Socket
+--                 -> SocketOption  -- Option Name
+--                 -> IO Int        -- Option Value
+-- getSocketOption (MkSocket s _ _ _ _) so = do
+--    (level, opt) <- packSocketOption' "getSocketOption" so
+--    alloca $ \ptr_v ->
+--      with (fromIntegral (sizeOf (undefined :: CInt))) $ \ptr_sz -> do
+--        throwSocketErrorIfMinus1Retry_ "getSocketOption" $
+--          c_getsockopt s level opt ptr_v ptr_sz
+--        fromIntegral `liftM` peek ptr_v
+
+
+-- #if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
+-- -- | Returns the processID, userID and groupID of the socket's peer.
+-- --
+-- -- Only available on platforms that support SO_PEERCRED or GETPEEREID(3)
+-- -- on domain sockets.
+-- -- GETPEEREID(3) returns userID and groupID. processID is always 0.
+-- getPeerCred :: Socket -> IO (CUInt, CUInt, CUInt)
+-- getPeerCred sock = do
+-- #ifdef HAVE_STRUCT_UCRED
+--   let fd = fdSocket sock
+--   let sz = (#const sizeof(struct ucred))
+--   allocaBytes sz $ \ ptr_cr ->
+--    with (fromIntegral sz) $ \ ptr_sz -> do
+--      _ <- ($) throwSocketErrorIfMinus1Retry "getPeerCred" $
+--        c_getsockopt fd (#const SOL_SOCKET) (#const SO_PEERCRED) ptr_cr ptr_sz
+--      pid <- (#peek struct ucred, pid) ptr_cr
+--      uid <- (#peek struct ucred, uid) ptr_cr
+--      gid <- (#peek struct ucred, gid) ptr_cr
+--      return (pid, uid, gid)
+-- #else
+--   (uid,gid) <- getPeerEid sock
+--   return (0,uid,gid)
+-- #endif
+
+-- #ifdef HAVE_GETPEEREID
+-- -- | The getpeereid() function returns the effective user and group IDs of the
+-- -- peer connected to a UNIX-domain socket
+-- getPeerEid :: Socket -> IO (CUInt, CUInt)
+-- getPeerEid sock = do
+--   let fd = fdSocket sock
+--   alloca $ \ ptr_uid ->
+--     alloca $ \ ptr_gid -> do
+--       throwSocketErrorIfMinus1Retry_ "getPeerEid" $
+--         c_getpeereid fd ptr_uid ptr_gid
+--       uid <- peek ptr_uid
+--       gid <- peek ptr_gid
+--       return (uid, gid)
+-- #endif
+-- #endif
+
+-- ##if !(MIN_VERSION_base(4,3,1))
+-- closeFdWith closer fd = closer fd
+-- ##endif
+
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+-- -- sending/receiving ancillary socket data; low-level mechanism
+-- -- for transmitting file descriptors, mainly.
+-- sendFd :: Socket -> CInt -> IO ()
+-- sendFd sock outfd = do
+--   _ <- ($) throwSocketErrorWaitWrite sock "sendFd" $
+--      c_sendFd (fdSocket sock) outfd
+--    -- Note: If Winsock supported FD-passing, thi would have been
+--    -- incorrect (since socket FDs need to be closed via closesocket().)
+--   closeFd outfd
+
+-- recvFd :: Socket -> IO CInt
+-- recvFd sock = do
+--   theFd <- throwSocketErrorWaitRead sock "recvFd" $
+--                c_recvFd (fdSocket sock)
+--   return theFd
+
+-- foreign import ccall SAFE_ON_WIN "sendFd" c_sendFd :: CInt -> CInt -> IO CInt
+-- foreign import ccall SAFE_ON_WIN "recvFd" c_recvFd :: CInt -> IO CInt
+
+-- #endif
+
+-- -- ---------------------------------------------------------------------------
+-- -- Utility Functions
+
+-- aNY_PORT :: PortNumber
+-- aNY_PORT = 0
+
+-- -- | The IPv4 wild card address.
+
+-- iNADDR_ANY :: HostAddress
+-- iNADDR_ANY = htonl (#const INADDR_ANY)
+
+-- -- | Converts the from host byte order to network byte order.
+-- foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
+-- -- | Converts the from network byte order to host byte order.
+-- foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
+
+-- #if defined(IPV6_SOCKET_SUPPORT)
+-- -- | The IPv6 wild card address.
+
+-- iN6ADDR_ANY :: HostAddress6
+-- iN6ADDR_ANY = (0, 0, 0, 0)
+-- #endif
+
+-- sOMAXCONN :: Int
+-- sOMAXCONN = #const SOMAXCONN
+
+-- sOL_SOCKET :: Int
+-- sOL_SOCKET = #const SOL_SOCKET
+
+-- #ifdef SCM_RIGHTS
+-- sCM_RIGHTS :: Int
+-- sCM_RIGHTS = #const SCM_RIGHTS
+-- #endif
+
+-- -- | This is the value of SOMAXCONN, typically 128.
+-- -- 128 is good enough for normal network servers but
+-- -- is too small for high performance servers.
+-- maxListenQueue :: Int
+-- maxListenQueue = sOMAXCONN
+
+-- -- -----------------------------------------------------------------------------
+
+-- data ShutdownCmd
+--  = ShutdownReceive
+--  | ShutdownSend
+--  | ShutdownBoth
+--  deriving Typeable
+
+-- sdownCmdToInt :: ShutdownCmd -> CInt
+-- sdownCmdToInt ShutdownReceive = 0
+-- sdownCmdToInt ShutdownSend    = 1
+-- sdownCmdToInt ShutdownBoth    = 2
+
+-- -- | Shut down one or both halves of the connection, depending on the
+-- -- second argument to the function.  If the second argument is
+-- -- 'ShutdownReceive', further receives are disallowed.  If it is
+-- -- 'ShutdownSend', further sends are disallowed.  If it is
+-- -- 'ShutdownBoth', further sends and receives are disallowed.
+-- shutdown :: Socket -> ShutdownCmd -> IO ()
+-- shutdown (MkSocket s _ _ _ _) stype = do
+--   throwSocketErrorIfMinus1Retry_ "shutdown" (c_shutdown s (sdownCmdToInt stype))
+--   return ()
+
+-- -- -----------------------------------------------------------------------------
+
+-- -- | Close the socket. Sending data to or receiving data from closed socket
+-- -- may lead to undefined behaviour.
+-- close :: Socket -> IO ()
+-- close (MkSocket s _ _ _ socketStatus) = do
+--  modifyMVar_ socketStatus $ \ status ->
+--    case status of
+--      ConvertedToHandle ->
+--          ioError (userError ("close: converted to a Handle, use hClose instead"))
+--      Closed ->
+--          return status
+--      _ -> closeFdWith (closeFd . fromIntegral) (fromIntegral s) >> return Closed
+
+-- -- -----------------------------------------------------------------------------
+
+-- -- | Determines whether 'close' has been used on the 'Socket'. This
+-- -- does /not/ indicate any status about the socket beyond this. If the
+-- -- socket has been closed remotely, this function can still return
+-- -- 'True'.
+-- isConnected :: Socket -> IO Bool
+-- isConnected (MkSocket _ _ _ _ status) = do
+--     value <- readMVar status
+--     return (value == Connected)
+
+-- -- -----------------------------------------------------------------------------
+-- -- Socket Predicates
+
+-- isBound :: Socket -> IO Bool
+-- isBound (MkSocket _ _ _ _ status) = do
+--     value <- readMVar status
+--     return (value == Bound)
+
+-- isListening :: Socket -> IO Bool
+-- isListening (MkSocket _ _ _  _ status) = do
+--     value <- readMVar status
+--     return (value == Listening)
+
+-- isReadable  :: Socket -> IO Bool
+-- isReadable (MkSocket _ _ _ _ status) = do
+--     value <- readMVar status
+--     return (value == Listening || value == Connected)
+
+-- isWritable  :: Socket -> IO Bool
+-- isWritable = isReadable -- sort of.
+
+-- isAcceptable :: Socket -> IO Bool
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+-- isAcceptable (MkSocket _ AF_UNIX x _ status)
+--     | x == Stream || x == SeqPacket = do
+--         value <- readMVar status
+--         return (value == Connected || value == Bound || value == Listening)
+-- isAcceptable (MkSocket _ AF_UNIX _ _ _) = return False
+-- #endif
+-- isAcceptable (MkSocket _ _ _ _ status) = do
+--     value <- readMVar status
+--     return (value == Connected || value == Listening)
+
+-- -- -----------------------------------------------------------------------------
+-- -- Internet address manipulation routines:
+
+-- inet_addr :: String -> IO HostAddress
+-- inet_addr ipstr = withSocketsDo $ do
+--    withCString ipstr $ \str -> do
+--    had <- c_inet_addr str
+--    if had == -1
+--     then ioError (userError ("inet_addr: Malformed address: " ++ ipstr))
+--     else return had  -- network byte order
+
+-- inet_ntoa :: HostAddress -> IO String
+-- inet_ntoa haddr = withSocketsDo $ do
+--   pstr <- c_inet_ntoa haddr
+--   peekCString pstr
+
+-- -- | Turns a Socket into an 'Handle'. By default, the new handle is
+-- -- unbuffered. Use 'System.IO.hSetBuffering' to change the buffering.
+-- --
+-- -- Note that since a 'Handle' is automatically closed by a finalizer
+-- -- when it is no longer referenced, you should avoid doing any more
+-- -- operations on the 'Socket' after calling 'socketToHandle'.  To
+-- -- close the 'Socket' after 'socketToHandle', call 'System.IO.hClose'
+-- -- on the 'Handle'.
+
+-- socketToHandle :: Socket -> IOMode -> IO Handle
+-- socketToHandle s@(MkSocket fd _ _ _ socketStatus) mode = do
+--  modifyMVar socketStatus $ \ status ->
+--     if status == ConvertedToHandle
+--         then ioError (userError ("socketToHandle: already a Handle"))
+--         else do
+--     h <- fdToHandle' (fromIntegral fd) (Just GHC.IO.Device.Stream) True (show s) mode True{-bin-}
+--     hSetBuffering h NoBuffering
+--     return (ConvertedToHandle, h)
+
+-- -- | Pack a list of values into a bitmask.  The possible mappings from
+-- -- value to bit-to-set are given as the first argument.  We assume
+-- -- that each value can cause exactly one bit to be set; unpackBits will
+-- -- break if this property is not true.
+
+-- packBits :: (Eq a, Num b, Bits b) => [(a, b)] -> [a] -> b
+
+-- packBits mapping xs = foldl' pack 0 mapping
+--     where pack acc (k, v) | k `elem` xs = acc .|. v
+--                           | otherwise   = acc
+
+-- -- | Unpack a bitmask into a list of values.
+
+-- unpackBits :: (Num b, Bits b) => [(a, b)] -> b -> [a]
+
+-- -- Be permissive and ignore unknown bit values. At least on OS X,
+-- -- getaddrinfo returns an ai_flags field with bits set that have no
+-- -- entry in <netdb.h>.
+-- unpackBits [] _    = []
+-- unpackBits ((k,v):xs) r
+--     | r .&. v /= 0 = k : unpackBits xs (r .&. complement v)
+--     | otherwise    = unpackBits xs r
+
+-- -----------------------------------------------------------------------------
+-- -- Address and service lookups
+
+-- #if defined(IPV6_SOCKET_SUPPORT)
+
+-- -- | Flags that control the querying behaviour of 'getAddrInfo'.
+-- --   For more information, see <https://tools.ietf.org/html/rfc3493#page-25>
+-- data AddrInfoFlag =
+--     -- | The list of returned 'AddrInfo' values will
+--     --   only contain IPv4 addresses if the local system has at least
+--     --   one IPv4 interface configured, and likewise for IPv6.
+--     --   (Only some platforms support this.)
+--       AI_ADDRCONFIG
+--     -- | If 'AI_ALL' is specified, return all matching IPv6 and
+--     --   IPv4 addresses.  Otherwise, this flag has no effect.
+--     --   (Only some platforms support this.)
+--     | AI_ALL
+--     -- | The 'addrCanonName' field of the first returned
+--     --   'AddrInfo' will contain the "canonical name" of the host.
+--     | AI_CANONNAME
+--     -- | The 'HostName' argument /must/ be a numeric
+--     --   address in string form, and network name lookups will not be
+--     --   attempted.
+--     | AI_NUMERICHOST
+--     -- | The 'ServiceName' argument /must/ be a port
+--     --   number in string form, and service name lookups will not be
+--     --   attempted. (Only some platforms support this.)
+--     | AI_NUMERICSERV
+--     -- | If no 'HostName' value is provided, the network
+--     --   address in each 'SockAddr'
+--     --   will be left as a "wild card", i.e. as either 'iNADDR_ANY'
+--     --   or 'iN6ADDR_ANY'.  This is useful for server applications that
+--     --   will accept connections from any client.
+--     | AI_PASSIVE
+--     -- | If an IPv6 lookup is performed, and no IPv6
+--     --   addresses are found, IPv6-mapped IPv4 addresses will be
+--     --   returned. (Only some platforms support this.)
+--     | AI_V4MAPPED
+--     deriving (Eq, Read, Show, Typeable)
+
+-- aiFlagMapping :: [(AddrInfoFlag, CInt)]
+
+-- aiFlagMapping =
+--     [
+-- #if HAVE_DECL_AI_ADDRCONFIG
+--      (AI_ADDRCONFIG, #const AI_ADDRCONFIG),
+-- #else
+--      (AI_ADDRCONFIG, 0),
+-- #endif
+-- #if HAVE_DECL_AI_ALL
+--      (AI_ALL, #const AI_ALL),
+-- #else
+--      (AI_ALL, 0),
+-- #endif
+--      (AI_CANONNAME, #const AI_CANONNAME),
+--      (AI_NUMERICHOST, #const AI_NUMERICHOST),
+-- #if HAVE_DECL_AI_NUMERICSERV
+--      (AI_NUMERICSERV, #const AI_NUMERICSERV),
+-- #else
+--      (AI_NUMERICSERV, 0),
+-- #endif
+--      (AI_PASSIVE, #const AI_PASSIVE),
+-- #if HAVE_DECL_AI_V4MAPPED
+--      (AI_V4MAPPED, #const AI_V4MAPPED)
+-- #else
+--      (AI_V4MAPPED, 0)
+-- #endif
+--     ]
+
+-- -- | Indicate whether the given 'AddrInfoFlag' will have any effect on
+-- -- this system.
+-- addrInfoFlagImplemented :: AddrInfoFlag -> Bool
+-- addrInfoFlagImplemented f = packBits aiFlagMapping [f] /= 0
+
+-- data AddrInfo =
+--     AddrInfo {
+--         addrFlags :: [AddrInfoFlag],
+--         addrFamily :: Family,
+--         addrSocketType :: SocketType,
+--         addrProtocol :: ProtocolNumber,
+--         addrAddress :: SockAddr,
+--         addrCanonName :: Maybe String
+--         }
+--     deriving (Eq, Show, Typeable)
+
+-- instance Storable AddrInfo where
+--     sizeOf    _ = #const sizeof(struct addrinfo)
+--     alignment _ = alignment (undefined :: CInt)
+
+--     peek p = do
+--         ai_flags <- (#peek struct addrinfo, ai_flags) p
+--         ai_family <- (#peek struct addrinfo, ai_family) p
+--         ai_socktype <- (#peek struct addrinfo, ai_socktype) p
+--         ai_protocol <- (#peek struct addrinfo, ai_protocol) p
+--         ai_addr <- (#peek struct addrinfo, ai_addr) p >>= peekSockAddr
+--         ai_canonname_ptr <- (#peek struct addrinfo, ai_canonname) p
+
+--         ai_canonname <- if ai_canonname_ptr == nullPtr
+--                         then return Nothing
+--                         else liftM Just $ peekCString ai_canonname_ptr
+
+--         socktype <- unpackSocketType' "AddrInfo.peek" ai_socktype
+--         return (AddrInfo
+--                 {
+--                  addrFlags = unpackBits aiFlagMapping ai_flags,
+--                  addrFamily = unpackFamily ai_family,
+--                  addrSocketType = socktype,
+--                  addrProtocol = ai_protocol,
+--                  addrAddress = ai_addr,
+--                  addrCanonName = ai_canonname
+--                 })
+
+--     poke p (AddrInfo flags family socketType protocol _ _) = do
+--         c_stype <- packSocketTypeOrThrow "AddrInfo.poke" socketType
+
+--         (#poke struct addrinfo, ai_flags) p (packBits aiFlagMapping flags)
+--         (#poke struct addrinfo, ai_family) p (packFamily family)
+--         (#poke struct addrinfo, ai_socktype) p c_stype
+--         (#poke struct addrinfo, ai_protocol) p protocol
+
+--         -- stuff below is probably not needed, but let's zero it for safety
+
+--         (#poke struct addrinfo, ai_addrlen) p (0::CSize)
+--         (#poke struct addrinfo, ai_addr) p nullPtr
+--         (#poke struct addrinfo, ai_canonname) p nullPtr
+--         (#poke struct addrinfo, ai_next) p nullPtr
+
+-- -- | Flags that control the querying behaviour of 'getNameInfo'.
+-- --   For more information, see <https://tools.ietf.org/html/rfc3493#page-30>
+-- data NameInfoFlag =
+--     -- | Resolve a datagram-based service name.  This is
+--     --   required only for the few protocols that have different port
+--     --   numbers for their datagram-based versions than for their
+--     --   stream-based versions.
+--       NI_DGRAM
+--     -- | If the hostname cannot be looked up, an IO error is thrown.
+--     | NI_NAMEREQD
+--     -- | If a host is local, return only the hostname part of the FQDN.
+--     | NI_NOFQDN
+--     -- | The name of the host is not looked up.
+--     --   Instead, a numeric representation of the host's
+--     --   address is returned.  For an IPv4 address, this will be a
+--     --   dotted-quad string.  For IPv6, it will be colon-separated
+--     --   hexadecimal.
+--     | NI_NUMERICHOST
+--     -- | The name of the service is not
+--     --   looked up.  Instead, a numeric representation of the
+--     --   service is returned.
+--     | NI_NUMERICSERV
+--     deriving (Eq, Read, Show, Typeable)
+
+-- niFlagMapping :: [(NameInfoFlag, CInt)]
+
+-- niFlagMapping = [(NI_DGRAM, #const NI_DGRAM),
+--                  (NI_NAMEREQD, #const NI_NAMEREQD),
+--                  (NI_NOFQDN, #const NI_NOFQDN),
+--                  (NI_NUMERICHOST, #const NI_NUMERICHOST),
+--                  (NI_NUMERICSERV, #const NI_NUMERICSERV)]
+
+-- -- | Default hints for address lookup with 'getAddrInfo'.  The values
+-- -- of the 'addrAddress' and 'addrCanonName' fields are 'undefined',
+-- -- and are never inspected by 'getAddrInfo'.
+-- --
+-- -- >>> addrFlags defaultHints
+-- -- []
+-- -- >>> addrFamily defaultHints
+-- -- AF_UNSPEC
+-- -- >>> addrSocketType defaultHints
+-- -- NoSocketType
+-- -- >>> addrProtocol defaultHints
+-- -- 0
+
+-- defaultHints :: AddrInfo
+-- defaultHints = AddrInfo {
+--                          addrFlags = [],
+--                          addrFamily = AF_UNSPEC,
+--                          addrSocketType = NoSocketType,
+--                          addrProtocol = defaultProtocol,
+--                          addrAddress = undefined,
+--                          addrCanonName = undefined
+--                         }
+
+-- -- | Resolve a host or service name to one or more addresses.
+-- -- The 'AddrInfo' values that this function returns contain 'SockAddr'
+-- -- values that you can pass directly to 'connect' or
+-- -- 'bind'.
+-- --
+-- -- This function is protocol independent.  It can return both IPv4 and
+-- -- IPv6 address information.
+-- --
+-- -- The 'AddrInfo' argument specifies the preferred query behaviour,
+-- -- socket options, or protocol.  You can override these conveniently
+-- -- using Haskell's record update syntax on 'defaultHints', for example
+-- -- as follows:
+-- --
+-- -- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
+-- --
+-- -- You must provide a 'Just' value for at least one of the 'HostName'
+-- -- or 'ServiceName' arguments.  'HostName' can be either a numeric
+-- -- network address (dotted quad for IPv4, colon-separated hex for
+-- -- IPv6) or a hostname.  In the latter case, its addresses will be
+-- -- looked up unless 'AI_NUMERICHOST' is specified as a hint.  If you
+-- -- do not provide a 'HostName' value /and/ do not set 'AI_PASSIVE' as
+-- -- a hint, network addresses in the result will contain the address of
+-- -- the loopback interface.
+-- --
+-- -- If the query fails, this function throws an IO exception instead of
+-- -- returning an empty list.  Otherwise, it returns a non-empty list
+-- -- of 'AddrInfo' values.
+-- --
+-- -- There are several reasons why a query might result in several
+-- -- values.  For example, the queried-for host could be multihomed, or
+-- -- the service might be available via several protocols.
+-- --
+-- -- Note: the order of arguments is slightly different to that defined
+-- -- for @getaddrinfo@ in RFC 2553.  The 'AddrInfo' parameter comes first
+-- -- to make partial application easier.
+-- --
+-- -- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
+-- -- >>> addrAddress addr
+-- -- 127.0.0.1:80
+
+-- getAddrInfo :: Maybe AddrInfo -- ^ preferred socket type or protocol
+--             -> Maybe HostName -- ^ host name to look up
+--             -> Maybe ServiceName -- ^ service name to look up
+--             -> IO [AddrInfo] -- ^ resolved addresses, with "best" first
+
+-- getAddrInfo hints node service = withSocketsDo $
+--   maybeWith withCString node $ \c_node ->
+--     maybeWith withCString service $ \c_service ->
+--       maybeWith with filteredHints $ \c_hints ->
+--         alloca $ \ptr_ptr_addrs -> do
+--           ret <- c_getaddrinfo c_node c_service c_hints ptr_ptr_addrs
+--           case ret of
+--             0 -> do ptr_addrs <- peek ptr_ptr_addrs
+--                     ais <- followAddrInfo ptr_addrs
+--                     c_freeaddrinfo ptr_addrs
+--                     return ais
+--             _ -> do err <- gai_strerror ret
+--                     ioError (ioeSetErrorString
+--                              (mkIOError NoSuchThing "getAddrInfo" Nothing
+--                               Nothing) err)
+--     -- Leaving out the service and using AI_NUMERICSERV causes a
+--     -- segfault on OS X 10.8.2. This code removes AI_NUMERICSERV
+--     -- (which has no effect) in that case.
+--   where
+-- #if defined(darwin_HOST_OS)
+--     filteredHints = case service of
+--         Nothing -> fmap (\ h -> h { addrFlags = delete AI_NUMERICSERV (addrFlags h) }) hints
+--         _       -> hints
+-- #else
+--     filteredHints = hints
+-- #endif
+
+-- followAddrInfo :: Ptr AddrInfo -> IO [AddrInfo]
+
+-- followAddrInfo ptr_ai | ptr_ai == nullPtr = return []
+--                       | otherwise = do
+--     a <- peek ptr_ai
+--     as <- (#peek struct addrinfo, ai_next) ptr_ai >>= followAddrInfo
+--     return (a:as)
+
+-- foreign import ccall safe "hsnet_getaddrinfo"
+--     c_getaddrinfo :: CString -> CString -> Ptr AddrInfo -> Ptr (Ptr AddrInfo)
+--                   -> IO CInt
+
+-- foreign import ccall safe "hsnet_freeaddrinfo"
+--     c_freeaddrinfo :: Ptr AddrInfo -> IO ()
+
+-- gai_strerror :: CInt -> IO String
+
+-- #ifdef HAVE_GAI_STRERROR
+-- gai_strerror n = c_gai_strerror n >>= peekCString
+
+-- foreign import ccall safe "gai_strerror"
+--     c_gai_strerror :: CInt -> IO CString
+-- #else
+-- gai_strerror n = return ("error " ++ show n)
+-- #endif
+
+-- withCStringIf :: Bool -> Int -> (CSize -> CString -> IO a) -> IO a
+-- withCStringIf False _ f = f 0 nullPtr
+-- withCStringIf True n f = allocaBytes n (f (fromIntegral n))
+
+-- -- | Resolve an address to a host or service name.
+-- -- This function is protocol independent.
+-- -- The list of 'NameInfoFlag' values controls query behaviour.
+-- --
+-- -- If a host or service's name cannot be looked up, then the numeric
+-- -- form of the address or service will be returned.
+-- --
+-- -- If the query fails, this function throws an IO exception.
+-- --
+-- -- Example:
+-- -- @
+-- --   (hostName, _) <- getNameInfo [] True False myAddress
+-- -- @
+
+-- getNameInfo :: [NameInfoFlag] -- ^ flags to control lookup behaviour
+--             -> Bool -- ^ whether to look up a hostname
+--             -> Bool -- ^ whether to look up a service name
+--             -> SockAddr -- ^ the address to look up
+--             -> IO (Maybe HostName, Maybe ServiceName)
+
+-- getNameInfo flags doHost doService addr = withSocketsDo $
+--   withCStringIf doHost (#const NI_MAXHOST) $ \c_hostlen c_host ->
+--     withCStringIf doService (#const NI_MAXSERV) $ \c_servlen c_serv -> do
+--       withSockAddr addr $ \ptr_addr sz -> do
+--         ret <- c_getnameinfo ptr_addr (fromIntegral sz) c_host c_hostlen
+--                              c_serv c_servlen (packBits niFlagMapping flags)
+--         case ret of
+--           0 -> do
+--             let peekIf doIf c_val = if doIf
+--                                      then liftM Just $ peekCString c_val
+--                                      else return Nothing
+--             host <- peekIf doHost c_host
+--             serv <- peekIf doService c_serv
+--             return (host, serv)
+--           _ -> do err <- gai_strerror ret
+--                   ioError (ioeSetErrorString
+--                            (mkIOError NoSuchThing "getNameInfo" Nothing
+--                             Nothing) err)
+
+-- foreign import ccall safe "hsnet_getnameinfo"
+--     c_getnameinfo :: Ptr SockAddr -> CInt{-CSockLen???-} -> CString -> CSize -> CString
+--                   -> CSize -> CInt -> IO CInt
+-- #endif
+
+-- mkInvalidRecvArgError :: String -> IOError
+-- mkInvalidRecvArgError loc = ioeSetErrorString (mkIOError
+--                                     InvalidArgument
+--                                     loc Nothing Nothing) "non-positive length"
+
+-- mkEOFError :: String -> IOError
+-- mkEOFError loc = ioeSetErrorString (mkIOError EOF loc Nothing Nothing) "end of file"
+
+-- -- ---------------------------------------------------------------------------
+-- -- foreign imports from the C library
+
+-- foreign import ccall unsafe "my_inet_ntoa"
+--   c_inet_ntoa :: HostAddress -> IO (Ptr CChar)
+
+-- foreign import CALLCONV unsafe "inet_addr"
+--   c_inet_addr :: Ptr CChar -> IO HostAddress
+
+-- foreign import CALLCONV unsafe "shutdown"
+--   c_shutdown :: CInt -> CInt -> IO CInt
+
+-- closeFd :: CInt -> IO ()
+-- closeFd fd = throwSocketErrorIfMinus1_ "Network.Socket.close" $ c_close fd
+
+-- #if !defined(WITH_WINSOCK)
+-- foreign import ccall unsafe "close"
+--   c_close :: CInt -> IO CInt
+-- #else
+-- foreign import stdcall unsafe "closesocket"
+--   c_close :: CInt -> IO CInt
+-- #endif
+
+-- foreign import CALLCONV unsafe "socket"
+--   c_socket :: CInt -> CInt -> CInt -> IO CInt
+-- foreign import CALLCONV unsafe "bind"
+--   c_bind :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
+-- foreign import CALLCONV SAFE_ON_WIN "connect"
+--   c_connect :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
+-- #ifdef HAVE_ACCEPT4
+-- foreign import CALLCONV unsafe "accept4"
+--   c_accept4 :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> CInt -> IO CInt
+-- #else
+-- foreign import CALLCONV unsafe "accept"
+--   c_accept :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
+-- #endif
+-- foreign import CALLCONV unsafe "listen"
+--   c_listen :: CInt -> CInt -> IO CInt
+
+-- #if defined(mingw32_HOST_OS)
+-- foreign import CALLCONV safe "accept"
+--   c_accept_safe :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
+
+-- foreign import ccall unsafe "rtsSupportsBoundThreads" threaded :: Bool
+-- #endif
+
+-- foreign import CALLCONV unsafe "send"
+--   c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
+-- foreign import CALLCONV SAFE_ON_WIN "sendto"
+--   c_sendto :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> CInt -> IO CInt
+-- foreign import CALLCONV unsafe "recv"
+--   c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
+-- foreign import CALLCONV SAFE_ON_WIN "recvfrom"
+--   c_recvfrom :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+-- foreign import CALLCONV unsafe "getpeername"
+--   c_getpeername :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+-- foreign import CALLCONV unsafe "getsockname"
+--   c_getsockname :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
+
+-- foreign import CALLCONV unsafe "getsockopt"
+--   c_getsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> Ptr CInt -> IO CInt
+-- foreign import CALLCONV unsafe "setsockopt"
+--   c_setsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> CInt -> IO CInt
+
+-- #if defined(HAVE_GETPEEREID)
+-- foreign import CALLCONV unsafe "getpeereid"
+--   c_getpeereid :: CInt -> Ptr CUInt -> Ptr CUInt -> IO CInt
+-- #endif
+-- -- ---------------------------------------------------------------------------
+-- -- * Deprecated aliases
+
+-- -- $deprecated-aliases
+-- --
+-- -- These aliases are deprecated and should not be used in new code.
+-- -- They will be removed in some future version of the package.
+
+-- {-# DEPRECATED bindSocket "use 'bind'" #-}
+
+-- -- | Deprecated alias for 'bind'.
+-- bindSocket :: Socket    -- Unconnected Socket
+--            -> SockAddr  -- Address to Bind to
+--            -> IO ()
+-- bindSocket = bind
+
+-- {-# DEPRECATED sClose "use 'close'" #-}
+
+-- -- | Deprecated alias for 'close'.
+-- sClose :: Socket -> IO ()
+-- sClose = close
+
+-- {-# DEPRECATED sIsConnected "use 'isConnected'" #-}
+
+-- -- | Deprecated alias for 'isConnected'.
+-- sIsConnected :: Socket -> IO Bool
+-- sIsConnected = isConnected
+
+-- {-# DEPRECATED sIsBound "use 'isBound'" #-}
+
+-- -- | Deprecated alias for 'isBound'.
+-- sIsBound :: Socket -> IO Bool
+-- sIsBound = isBound
+
+-- {-# DEPRECATED sIsListening "use 'isListening'" #-}
+
+-- -- | Deprecated alias for 'isListening'.
+-- sIsListening :: Socket -> IO Bool
+-- sIsListening = isListening
+
+-- {-# DEPRECATED sIsReadable "use 'isReadable'" #-}
+
+-- -- | Deprecated alias for 'isReadable'.
+-- sIsReadable  :: Socket -> IO Bool
+-- sIsReadable = isReadable
+
+-- {-# DEPRECATED sIsWritable "use 'isWritable'" #-}
+
+-- -- | Deprecated alias for 'isWritable'.
+-- sIsWritable  :: Socket -> IO Bool
+-- sIsWritable = isWritable
diff --git a/Network/Socket.hsc b/Network/Socket.hsc
deleted file mode 100644
index 8b2e6fe..0000000
--- a/Network/Socket.hsc
+++ /dev/null
@@ -1,1660 +0,0 @@
-{-# LANGUAGE CPP, ScopedTypeVariables #-}
-{-# OPTIONS_GHC -fno-warn-orphans #-}
------------------------------------------------------------------------------
--- |
--- Module      :  Network.Socket
--- Copyright   :  (c) The University of Glasgow 2001
--- License     :  BSD-style (see the file libraries/network/LICENSE)
---
--- Maintainer  :  libraries@haskell.org
--- Stability   :  provisional
--- Portability :  portable
---
--- The "Network.Socket" module is for when you want full control over
--- sockets.  Essentially the entire C socket API is exposed through
--- this module; in general the operations follow the behaviour of the C
--- functions of the same name (consult your favourite Unix networking book).
---
--- A higher level interface to networking operations is provided
--- through the module "Network".
---
------------------------------------------------------------------------------
-
-#include "HsNet.h"
-
--- In order to process this file, you need to have CALLCONV defined.
-
-module Network.Socket
-    (
-    -- * Types
-      Socket(..)
-    , Family(..)
-    , isSupportedFamily
-    , SocketType(..)
-    , isSupportedSocketType
-    , SockAddr(..)
-    , isSupportedSockAddr
-    , SocketStatus(..)
-    , HostAddress
-    , hostAddressToTuple
-    , tupleToHostAddress
-#if defined(IPV6_SOCKET_SUPPORT)
-    , HostAddress6
-    , hostAddress6ToTuple
-    , tupleToHostAddress6
-    , FlowInfo
-    , ScopeID
-#endif
-    , htonl
-    , ntohl
-    , ShutdownCmd(..)
-    , ProtocolNumber
-    , defaultProtocol
-    , PortNumber(..)
-    -- PortNumber is used non-abstractly in Network.BSD.  ToDo: remove
-    -- this use and make the type abstract.
-
-    -- * Address operations
-
-    , HostName
-    , ServiceName
-
-#if defined(IPV6_SOCKET_SUPPORT)
-    , AddrInfo(..)
-
-    , AddrInfoFlag(..)
-    , addrInfoFlagImplemented
-
-    , defaultHints
-
-    , getAddrInfo
-
-    , NameInfoFlag(..)
-
-    , getNameInfo
-#endif
-
-    -- * Socket operations
-    , socket
-#if defined(DOMAIN_SOCKET_SUPPORT)
-    , socketPair
-#endif
-    , connect
-    , bind
-    , listen
-    , accept
-    , getPeerName
-    , getSocketName
-
-#if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
-    -- get the credentials of our domain socket peer.
-    , getPeerCred
-#if defined(HAVE_GETPEEREID)
-    , getPeerEid
-#endif
-#endif
-
-    , socketPort
-
-    , socketToHandle
-
-    -- ** Sending and receiving data
-    -- *** Sending and receiving with String
-    -- $sendrecv
-    , send
-    , sendTo
-    , recv
-    , recvFrom
-    , recvLen
-
-    -- *** Sending and receiving with a buffer
-    , sendBuf
-    , recvBuf
-    , sendBufTo
-    , recvBufFrom
-
-    -- ** Misc
-    , inet_addr
-    , inet_ntoa
-
-    , shutdown
-    , close
-
-    -- ** Predicates on sockets
-    , isConnected
-    , isBound
-    , isListening
-    , isReadable
-    , isWritable
-
-    -- * Socket options
-    , SocketOption(..)
-    , isSupportedSocketOption
-    , getSocketOption
-    , setSocketOption
-
-    -- * File descriptor transmission
-#ifdef DOMAIN_SOCKET_SUPPORT
-    , sendFd
-    , recvFd
-
-#endif
-
-    -- * Special constants
-    , aNY_PORT
-    , iNADDR_ANY
-#if defined(IPV6_SOCKET_SUPPORT)
-    , iN6ADDR_ANY
-#endif
-    , sOMAXCONN
-    , sOL_SOCKET
-#ifdef SCM_RIGHTS
-    , sCM_RIGHTS
-#endif
-    , maxListenQueue
-
-    -- * Initialisation
-    , withSocketsDo
-
-    -- * Very low level operations
-    -- in case you ever want to get at the underlying file descriptor..
-    , fdSocket
-    , mkSocket
-
-    -- * Deprecated aliases
-    -- $deprecated-aliases
-    , bindSocket
-    , sClose
-    , sIsConnected
-    , sIsBound
-    , sIsListening
-    , sIsReadable
-    , sIsWritable
-
-    -- * Internal
-
-    -- | The following are exported ONLY for use in the BSD module and
-    -- should not be used anywhere else.
-
-    , packFamily
-    , unpackFamily
-    , packSocketType
-    ) where
-
-import Data.Bits
-import Data.Functor
-import Data.List (foldl')
-import Data.Maybe (isJust)
-import Data.Word (Word8, Word32)
-import Foreign.Ptr (Ptr, castPtr, nullPtr)
-import Foreign.Storable (Storable(..))
-import Foreign.C.Error
-import Foreign.C.String (CString, withCString, withCStringLen, peekCString, peekCStringLen)
-import Foreign.C.Types (CUInt, CChar)
-import Foreign.C.Types (CInt(..), CSize(..))
-import Foreign.Marshal.Alloc ( alloca, allocaBytes )
-import Foreign.Marshal.Array ( peekArray )
-import Foreign.Marshal.Utils ( maybeWith, with )
-
-import System.IO
-import Control.Monad (liftM, when)
-
-import Control.Concurrent.MVar
-import Data.Typeable
-import System.IO.Error
-
-import GHC.Conc (threadWaitRead, threadWaitWrite)
-##if MIN_VERSION_base(4,3,1)
-import GHC.Conc (closeFdWith)
-##endif
-# if defined(mingw32_HOST_OS)
-import qualified Control.Exception as E
-import GHC.Conc (asyncDoProc)
-import GHC.IO.FD (FD(..), readRawBufferPtr, writeRawBufferPtr)
-import Foreign (FunPtr)
-# endif
-# if defined(darwin_HOST_OS)
-import Data.List (delete)
-# endif
-import qualified GHC.IO.Device
-import GHC.IO.Handle.FD
-import GHC.IO.Exception
-import GHC.IO
-import qualified System.Posix.Internals
-
-import Network.Socket.Internal
-import Network.Socket.Types
-
-import Prelude -- Silence AMP warnings
-
--- | Either a host name e.g., @\"haskell.org\"@ or a numeric host
--- address string consisting of a dotted decimal IPv4 address or an
--- IPv6 address e.g., @\"192.168.0.1\"@.
-type HostName       = String
-type ServiceName    = String
-
--- ----------------------------------------------------------------------------
--- On Windows, our sockets are not put in non-blocking mode (non-blocking
--- is not supported for regular file descriptors on Windows, and it would
--- be a pain to support it only for sockets).  So there are two cases:
---
---  - the threaded RTS uses safe calls for socket operations to get
---    non-blocking I/O, just like the rest of the I/O library
---
---  - with the non-threaded RTS, only some operations on sockets will be
---    non-blocking.  Reads and writes go through the normal async I/O
---    system.  accept() uses asyncDoProc so is non-blocking.  A handful
---    of others (recvFrom, sendFd, recvFd) will block all threads - if this
---    is a problem, -threaded is the workaround.
---
-##if defined(mingw32_HOST_OS)
-##define SAFE_ON_WIN safe
-##else
-##define SAFE_ON_WIN unsafe
-##endif
-
------------------------------------------------------------------------------
--- Socket types
-
-#if defined(mingw32_HOST_OS)
-socket2FD  (MkSocket fd _ _ _ _) =
-  -- HACK, 1 means True
-  FD{fdFD = fd,fdIsSocket_ = 1}
-#endif
-
-mkSocket :: CInt
-         -> Family
-         -> SocketType
-         -> ProtocolNumber
-         -> SocketStatus
-         -> IO Socket
-mkSocket fd fam sType pNum stat = do
-   mStat <- newMVar stat
-   withSocketsDo $ return ()
-   return (MkSocket fd fam sType pNum mStat)
-
-
-fdSocket :: Socket -> CInt
-fdSocket (MkSocket fd _ _ _ _) = fd
-
--- | This is the default protocol for a given service.
-defaultProtocol :: ProtocolNumber
-defaultProtocol = 0
-
------------------------------------------------------------------------------
--- SockAddr
-
-instance Show SockAddr where
-#if defined(DOMAIN_SOCKET_SUPPORT)
-  showsPrec _ (SockAddrUnix str) = showString str
-#endif
-  showsPrec _ (SockAddrInet port ha)
-   = showString (unsafePerformIO (inet_ntoa ha))
-   . showString ":"
-   . shows port
-#if defined(IPV6_SOCKET_SUPPORT)
-  showsPrec _ addr@(SockAddrInet6 port _ _ _)
-   = showChar '['
-   . showString (unsafePerformIO $
-                 fst `liftM` getNameInfo [NI_NUMERICHOST] True False addr >>=
-                 maybe (fail "showsPrec: impossible internal error") return)
-   . showString "]:"
-   . shows port
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-  showsPrec _ (SockAddrCan ifidx) = shows ifidx
-#endif
-
------------------------------------------------------------------------------
--- Connection Functions
-
--- In the following connection and binding primitives.  The names of
--- the equivalent C functions have been preserved where possible. It
--- should be noted that some of these names used in the C library,
--- \tr{bind} in particular, have a different meaning to many Haskell
--- programmers and have thus been renamed by appending the prefix
--- Socket.
-
--- | Create a new socket using the given address family, socket type
--- and protocol number.  The address family is usually 'AF_INET',
--- 'AF_INET6', or 'AF_UNIX'.  The socket type is usually 'Stream' or
--- 'Datagram'.  The protocol number is usually 'defaultProtocol'.
--- If 'AF_INET6' is used and the socket type is 'Stream' or 'Datagram',
--- the 'IPv6Only' socket option is set to 0 so that both IPv4 and IPv6
--- can be handled with one socket.
---
--- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
--- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
--- >>> sock@(MkSocket _ fam stype _ _) <- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--- >>> fam
--- AF_INET
--- >>> stype
--- Stream
--- >>> bind sock (addrAddress addr)
--- >>> getSocketName sock
--- 127.0.0.1:5000
-socket :: Family         -- Family Name (usually AF_INET)
-       -> SocketType     -- Socket Type (usually Stream)
-       -> ProtocolNumber -- Protocol Number (getProtocolByName to find value)
-       -> IO Socket      -- Unconnected Socket
-socket family stype protocol = do
-    c_stype <- packSocketTypeOrThrow "socket" stype
-    fd <- throwSocketErrorIfMinus1Retry "socket" $
-                c_socket (packFamily family) c_stype protocol
-    setNonBlockIfNeeded fd
-    socket_status <- newMVar NotConnected
-    withSocketsDo $ return ()
-    let sock = MkSocket fd family stype protocol socket_status
-#if HAVE_DECL_IPV6_V6ONLY
-    -- The default value of the IPv6Only option is platform specific,
-    -- so we explicitly set it to 0 to provide a common default.
-# if defined(mingw32_HOST_OS)
-    -- The IPv6Only option is only supported on Windows Vista and later,
-    -- so trying to change it might throw an error.
-    when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
-      E.catch (setSocketOption sock IPv6Only 0) $ (\(_ :: E.IOException) -> return ())
-# else
-    when (family == AF_INET6 && (stype == Stream || stype == Datagram)) $
-      setSocketOption sock IPv6Only 0 `onException` close sock
-# endif
-#endif
-    return sock
-
--- | Build a pair of connected socket objects using the given address
--- family, socket type, and protocol number.  Address family, socket
--- type, and protocol number are as for the 'socket' function above.
--- Availability: Unix.
-#if defined(DOMAIN_SOCKET_SUPPORT)
-socketPair :: Family              -- Family Name (usually AF_INET or AF_INET6)
-           -> SocketType          -- Socket Type (usually Stream)
-           -> ProtocolNumber      -- Protocol Number
-           -> IO (Socket, Socket) -- unnamed and connected.
-socketPair family stype protocol = do
-    allocaBytes (2 * sizeOf (1 :: CInt)) $ \ fdArr -> do
-    c_stype <- packSocketTypeOrThrow "socketPair" stype
-    _rc <- throwSocketErrorIfMinus1Retry "socketpair" $
-                c_socketpair (packFamily family) c_stype protocol fdArr
-    [fd1,fd2] <- peekArray 2 fdArr
-    s1 <- mkNonBlockingSocket fd1
-    s2 <- mkNonBlockingSocket fd2
-    return (s1,s2)
-  where
-    mkNonBlockingSocket fd = do
-       setNonBlockIfNeeded fd
-       stat <- newMVar Connected
-       withSocketsDo $ return ()
-       return (MkSocket fd family stype protocol stat)
-
-foreign import ccall unsafe "socketpair"
-  c_socketpair :: CInt -> CInt -> CInt -> Ptr CInt -> IO CInt
-#endif
-
--- | Set the socket to nonblocking, if applicable to this platform.
-setNonBlockIfNeeded :: CInt -> IO ()
-setNonBlockIfNeeded fd =
-    System.Posix.Internals.setNonBlockingFD fd True
-
------------------------------------------------------------------------------
--- Binding a socket
-
--- | Bind the socket to an address. The socket must not already be
--- bound.  The 'Family' passed to @bind@ must be the
--- same as that passed to 'socket'.  If the special port number
--- 'aNY_PORT' is passed then the system assigns the next available
--- use port.
-bind :: Socket    -- Unconnected Socket
-           -> SockAddr  -- Address to Bind to
-           -> IO ()
-bind (MkSocket s _family _stype _protocol socketStatus) addr = do
- modifyMVar_ socketStatus $ \ status -> do
- if status /= NotConnected
-  then
-   ioError (userError ("bind: can't peform bind on socket in status " ++
-         show status))
-  else do
-   withSockAddr addr $ \p_addr sz -> do
-   _status <- throwSocketErrorIfMinus1Retry "bind" $ c_bind s p_addr (fromIntegral sz)
-   return Bound
-
------------------------------------------------------------------------------
--- Connecting a socket
-
--- | Connect to a remote socket at address.
-connect :: Socket    -- Unconnected Socket
-        -> SockAddr  -- Socket address stuff
-        -> IO ()
-connect sock@(MkSocket s _family _stype _protocol socketStatus) addr = withSocketsDo $ do
- modifyMVar_ socketStatus $ \currentStatus -> do
- if currentStatus /= NotConnected && currentStatus /= Bound
-  then
-    ioError (userError ("connect: can't peform connect on socket in status " ++
-        show currentStatus))
-  else do
-    withSockAddr addr $ \p_addr sz -> do
-
-    let connectLoop = do
-           r <- c_connect s p_addr (fromIntegral sz)
-           if r == -1
-               then do
-#if !(defined(HAVE_WINSOCK2_H))
-                   err <- getErrno
-                   case () of
-                     _ | err == eINTR       -> connectLoop
-                     _ | err == eINPROGRESS -> connectBlocked
---                   _ | err == eAGAIN      -> connectBlocked
-                     _otherwise             -> throwSocketError "connect"
-#else
-                   throwSocketError "connect"
-#endif
-               else return ()
-
-        connectBlocked = do
-           threadWaitWrite (fromIntegral s)
-           err <- getSocketOption sock SoError
-           if (err == 0)
-                then return ()
-                else throwSocketErrorCode "connect" (fromIntegral err)
-
-    connectLoop
-    return Connected
-
------------------------------------------------------------------------------
--- Listen
-
--- | Listen for connections made to the socket.  The second argument
--- specifies the maximum number of queued connections and should be at
--- least 1; the maximum value is system-dependent (usually 5).
-listen :: Socket  -- Connected & Bound Socket
-       -> Int     -- Queue Length
-       -> IO ()
-listen (MkSocket s _family _stype _protocol socketStatus) backlog = do
- modifyMVar_ socketStatus $ \ status -> do
- if status /= Bound
-   then
-     ioError (userError ("listen: can't peform listen on socket in status " ++
-         show status))
-   else do
-     throwSocketErrorIfMinus1Retry_ "listen" (c_listen s (fromIntegral backlog))
-     return Listening
-
------------------------------------------------------------------------------
--- Accept
---
--- A call to `accept' only returns when data is available on the given
--- socket, unless the socket has been set to non-blocking.  It will
--- return a new socket which should be used to read the incoming data and
--- should then be closed. Using the socket returned by `accept' allows
--- incoming requests to be queued on the original socket.
-
--- | Accept a connection.  The socket must be bound to an address and
--- listening for connections.  The return value is a pair @(conn,
--- address)@ where @conn@ is a new socket object usable to send and
--- receive data on the connection, and @address@ is the address bound
--- to the socket on the other end of the connection.
-accept :: Socket                        -- Queue Socket
-       -> IO (Socket,                   -- Readable Socket
-              SockAddr)                 -- Peer details
-
-accept sock@(MkSocket s family stype protocol status) = do
- currentStatus <- readMVar status
- okay <- isAcceptable sock
- if not okay
-   then
-     ioError (userError ("accept: can't perform accept on socket (" ++ (show (family,stype,protocol)) ++") in status " ++
-         show currentStatus))
-   else do
-     let sz = sizeOfSockAddrByFamily family
-     allocaBytes sz $ \ sockaddr -> do
-#if defined(mingw32_HOST_OS)
-     new_sock <-
-        if threaded
-           then with (fromIntegral sz) $ \ ptr_len ->
-                  throwSocketErrorIfMinus1Retry "Network.Socket.accept" $
-                    c_accept_safe s sockaddr ptr_len
-           else do
-                paramData <- c_newAcceptParams s (fromIntegral sz) sockaddr
-                rc        <- asyncDoProc c_acceptDoProc paramData
-                new_sock  <- c_acceptNewSock    paramData
-                c_free paramData
-                when (rc /= 0) $
-                     throwSocketErrorCode "Network.Socket.accept" (fromIntegral rc)
-                return new_sock
-#else
-     with (fromIntegral sz) $ \ ptr_len -> do
-# ifdef HAVE_ACCEPT4
-     new_sock <- throwSocketErrorIfMinus1RetryMayBlock "accept"
-                        (threadWaitRead (fromIntegral s))
-                        (c_accept4 s sockaddr ptr_len (#const SOCK_NONBLOCK))
-# else
-     new_sock <- throwSocketErrorWaitRead sock "accept"
-                        (c_accept s sockaddr ptr_len)
-     setNonBlockIfNeeded new_sock
-# endif /* HAVE_ACCEPT4 */
-#endif
-     addr <- peekSockAddr sockaddr
-     new_status <- newMVar Connected
-     return ((MkSocket new_sock family stype protocol new_status), addr)
-
-#if defined(mingw32_HOST_OS)
-foreign import ccall unsafe "HsNet.h acceptNewSock"
-  c_acceptNewSock :: Ptr () -> IO CInt
-foreign import ccall unsafe "HsNet.h newAcceptParams"
-  c_newAcceptParams :: CInt -> CInt -> Ptr a -> IO (Ptr ())
-foreign import ccall unsafe "HsNet.h &acceptDoProc"
-  c_acceptDoProc :: FunPtr (Ptr () -> IO Int)
-foreign import ccall unsafe "free"
-  c_free:: Ptr a -> IO ()
-#endif
-
------------------------------------------------------------------------------
--- ** Sending and reciving data
-
--- $sendrecv
---
--- Do not use the @send@ and @recv@ functions defined in this section
--- in new code, as they incorrectly represent binary data as a Unicode
--- string.  As a result, these functions are inefficient and may lead
--- to bugs in the program.  Instead use the @send@ and @recv@
--- functions defined in the "Network.Socket.ByteString" module.
-
------------------------------------------------------------------------------
--- sendTo & recvFrom
-
--- | Send data to the socket.  The recipient can be specified
--- explicitly, so the socket need not be in a connected state.
--- Returns the number of bytes sent.  Applications are responsible for
--- ensuring that all data has been sent.
---
--- NOTE: blocking on Windows unless you compile with -threaded (see
--- GHC ticket #1129)
-{-# WARNING sendTo "Use sendTo defined in \"Network.Socket.ByteString\"" #-}
-sendTo :: Socket        -- (possibly) bound/connected Socket
-       -> String        -- Data to send
-       -> SockAddr
-       -> IO Int        -- Number of Bytes sent
-sendTo sock xs addr = do
- withCStringLen xs $ \(str, len) -> do
-   sendBufTo sock str len addr
-
--- | Send data to the socket.  The recipient can be specified
--- explicitly, so the socket need not be in a connected state.
--- Returns the number of bytes sent.  Applications are responsible for
--- ensuring that all data has been sent.
-sendBufTo :: Socket            -- (possibly) bound/connected Socket
-          -> Ptr a -> Int  -- Data to send
-          -> SockAddr
-          -> IO Int            -- Number of Bytes sent
-sendBufTo sock@(MkSocket s _family _stype _protocol _status) ptr nbytes addr = do
- withSockAddr addr $ \p_addr sz -> do
-   liftM fromIntegral $
-     throwSocketErrorWaitWrite sock "sendTo" $
-        c_sendto s ptr (fromIntegral $ nbytes) 0{-flags-}
-                        p_addr (fromIntegral sz)
-
--- | Receive data from the socket. The socket need not be in a
--- connected state. Returns @(bytes, nbytes, address)@ where @bytes@
--- is a @String@ of length @nbytes@ representing the data received and
--- @address@ is a 'SockAddr' representing the address of the sending
--- socket.
---
--- NOTE: blocking on Windows unless you compile with -threaded (see
--- GHC ticket #1129)
-{-# WARNING recvFrom "Use recvFrom defined in \"Network.Socket.ByteString\"" #-}
-recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)
-recvFrom sock nbytes =
-  allocaBytes nbytes $ \ptr -> do
-    (len, sockaddr) <- recvBufFrom sock ptr nbytes
-    str <- peekCStringLen (ptr, len)
-    return (str, len, sockaddr)
-
--- | Receive data from the socket, writing it into buffer instead of
--- creating a new string.  The socket need not be in a connected
--- state. Returns @(nbytes, address)@ where @nbytes@ is the number of
--- bytes received and @address@ is a 'SockAddr' representing the
--- address of the sending socket.
---
--- NOTE: blocking on Windows unless you compile with -threaded (see
--- GHC ticket #1129)
-recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
-recvBufFrom sock@(MkSocket s family _stype _protocol _status) ptr nbytes
- | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvFrom")
- | otherwise   =
-    withNewSockAddr family $ \ptr_addr sz -> do
-      alloca $ \ptr_len -> do
-        poke ptr_len (fromIntegral sz)
-        len <- throwSocketErrorWaitRead sock "recvFrom" $
-                   c_recvfrom s ptr (fromIntegral nbytes) 0{-flags-}
-                                ptr_addr ptr_len
-        let len' = fromIntegral len
-        if len' == 0
-         then ioError (mkEOFError "Network.Socket.recvFrom")
-         else do
-           flg <- isConnected sock
-             -- For at least one implementation (WinSock 2), recvfrom() ignores
-             -- filling in the sockaddr for connected TCP sockets. Cope with
-             -- this by using getPeerName instead.
-           sockaddr <-
-                if flg then
-                   getPeerName sock
-                else
-                   peekSockAddr ptr_addr
-           return (len', sockaddr)
-
------------------------------------------------------------------------------
--- send & recv
-
--- | Send data to the socket. The socket must be connected to a remote
--- socket. Returns the number of bytes sent.  Applications are
--- responsible for ensuring that all data has been sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-{-# WARNING send "Use send defined in \"Network.Socket.ByteString\"" #-}
-send :: Socket  -- Bound/Connected Socket
-     -> String  -- Data to send
-     -> IO Int  -- Number of Bytes sent
-send sock xs = withCStringLen xs $ \(str, len) ->
-    sendBuf sock (castPtr str) len
-
--- | Send data to the socket. The socket must be connected to a remote
--- socket. Returns the number of bytes sent.  Applications are
--- responsible for ensuring that all data has been sent.
---
--- Sending data to closed socket may lead to undefined behaviour.
-sendBuf :: Socket     -- Bound/Connected Socket
-        -> Ptr Word8  -- Pointer to the data to send
-        -> Int        -- Length of the buffer
-        -> IO Int     -- Number of Bytes sent
-sendBuf sock@(MkSocket s _family _stype _protocol _status) str len = do
-   liftM fromIntegral $
-#if defined(mingw32_HOST_OS)
--- writeRawBufferPtr is supposed to handle checking for errors, but it's broken
--- on x86_64 because of GHC bug #12010 so we duplicate the check here. The call
--- to throwSocketErrorIfMinus1Retry can be removed when no GHC version with the
--- bug is supported.
-    throwSocketErrorIfMinus1Retry "Network.Socket.sendBuf" $ writeRawBufferPtr
-      "Network.Socket.sendBuf"
-      (socket2FD sock)
-      (castPtr str)
-      0
-      (fromIntegral len)
-#else
-     throwSocketErrorWaitWrite sock "sendBuf" $
-        c_send s str (fromIntegral len) 0{-flags-}
-#endif
-
-
--- | Receive data from the socket.  The socket must be in a connected
--- state. This function may return fewer bytes than specified.  If the
--- message is longer than the specified length, it may be discarded
--- depending on the type of socket.  This function may block until a
--- message arrives.
---
--- Considering hardware and network realities, the maximum number of
--- bytes to receive should be a small power of 2, e.g., 4096.
---
--- For TCP sockets, a zero length return value means the peer has
--- closed its half side of the connection.
---
--- Receiving data from closed socket may lead to undefined behaviour.
-{-# WARNING recv "Use recv defined in \"Network.Socket.ByteString\"" #-}
-recv :: Socket -> Int -> IO String
-recv sock l = fst <$> recvLen sock l
-
-{-# WARNING recvLen "Use recvLen defined in \"Network.Socket.ByteString\"" #-}
-recvLen :: Socket -> Int -> IO (String, Int)
-recvLen sock nbytes =
-     allocaBytes nbytes $ \ptr -> do
-        len <- recvBuf sock ptr nbytes
-        s <- peekCStringLen (castPtr ptr,len)
-        return (s, len)
-
--- | Receive data from the socket.  The socket must be in a connected
--- state. This function may return fewer bytes than specified.  If the
--- message is longer than the specified length, it may be discarded
--- depending on the type of socket.  This function may block until a
--- message arrives.
---
--- Considering hardware and network realities, the maximum number of
--- bytes to receive should be a small power of 2, e.g., 4096.
---
--- For TCP sockets, a zero length return value means the peer has
--- closed its half side of the connection.
---
--- Receiving data from closed socket may lead to undefined behaviour.
-recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int
-recvBuf sock@(MkSocket s _family _stype _protocol _status) ptr nbytes
- | nbytes <= 0 = ioError (mkInvalidRecvArgError "Network.Socket.recvBuf")
- | otherwise   = do
-        len <-
-#if defined(mingw32_HOST_OS)
--- see comment in sendBuf above.
-            throwSocketErrorIfMinus1Retry "Network.Socket.recvBuf" $
-                readRawBufferPtr "Network.Socket.recvBuf"
-                (socket2FD sock) ptr 0 (fromIntegral nbytes)
-#else
-               throwSocketErrorWaitRead sock "recvBuf" $
-                   c_recv s (castPtr ptr) (fromIntegral nbytes) 0{-flags-}
-#endif
-        let len' = fromIntegral len
-        if len' == 0
-         then ioError (mkEOFError "Network.Socket.recvBuf")
-         else return len'
-
-
--- ---------------------------------------------------------------------------
--- socketPort
---
--- The port number the given socket is currently connected to can be
--- determined by calling $port$, is generally only useful when bind
--- was given $aNY\_PORT$.
-
-socketPort :: Socket            -- Connected & Bound Socket
-           -> IO PortNumber     -- Port Number of Socket
-socketPort sock@(MkSocket _ AF_INET _ _ _) = do
-    (SockAddrInet port _) <- getSocketName sock
-    return port
-#if defined(IPV6_SOCKET_SUPPORT)
-socketPort sock@(MkSocket _ AF_INET6 _ _ _) = do
-    (SockAddrInet6 port _ _ _) <- getSocketName sock
-    return port
-#endif
-socketPort (MkSocket _ family _ _ _) =
-    ioError (userError ("socketPort: not supported for Family " ++ show family))
-
-
--- ---------------------------------------------------------------------------
--- getPeerName
-
--- Calling $getPeerName$ returns the address details of the machine,
--- other than the local one, which is connected to the socket. This is
--- used in programs such as FTP to determine where to send the
--- returning data.  The corresponding call to get the details of the
--- local machine is $getSocketName$.
-
-getPeerName   :: Socket -> IO SockAddr
-getPeerName (MkSocket s family _ _ _) = do
- withNewSockAddr family $ \ptr sz -> do
-   with (fromIntegral sz) $ \int_star -> do
-   throwSocketErrorIfMinus1Retry_ "getPeerName" $ c_getpeername s ptr int_star
-   _sz <- peek int_star
-   peekSockAddr ptr
-
-getSocketName :: Socket -> IO SockAddr
-getSocketName (MkSocket s family _ _ _) = do
- withNewSockAddr family $ \ptr sz -> do
-   with (fromIntegral sz) $ \int_star -> do
-   throwSocketErrorIfMinus1Retry_ "getSocketName" $ c_getsockname s ptr int_star
-   peekSockAddr ptr
-
------------------------------------------------------------------------------
--- Socket Properties
-
--- | Socket options for use with 'setSocketOption' and 'getSocketOption'.
---
--- The existence of a constructor does not imply that the relevant option
--- is supported on your system: see 'isSupportedSocketOption'
-data SocketOption
-    = Debug         -- ^ SO_DEBUG
-    | ReuseAddr     -- ^ SO_REUSEADDR
-    | Type          -- ^ SO_TYPE
-    | SoError       -- ^ SO_ERROR
-    | DontRoute     -- ^ SO_DONTROUTE
-    | Broadcast     -- ^ SO_BROADCAST
-    | SendBuffer    -- ^ SO_SNDBUF
-    | RecvBuffer    -- ^ SO_RCVBUF
-    | KeepAlive     -- ^ SO_KEEPALIVE
-    | OOBInline     -- ^ SO_OOBINLINE
-    | TimeToLive    -- ^ IP_TTL
-    | MaxSegment    -- ^ TCP_MAXSEG
-    | NoDelay       -- ^ TCP_NODELAY
-    | Cork          -- ^ TCP_CORK
-    | Linger        -- ^ SO_LINGER
-    | ReusePort     -- ^ SO_REUSEPORT
-    | RecvLowWater  -- ^ SO_RCVLOWAT
-    | SendLowWater  -- ^ SO_SNDLOWAT
-    | RecvTimeOut   -- ^ SO_RCVTIMEO
-    | SendTimeOut   -- ^ SO_SNDTIMEO
-    | UseLoopBack   -- ^ SO_USELOOPBACK
-    | UserTimeout   -- ^ TCP_USER_TIMEOUT
-    | IPv6Only      -- ^ IPV6_V6ONLY
-    | CustomSockOpt (CInt, CInt)
-    deriving (Show, Typeable)
-
--- | Does the 'SocketOption' exist on this system?
-isSupportedSocketOption :: SocketOption -> Bool
-isSupportedSocketOption = isJust . packSocketOption
-
--- | For a socket option, return Just (level, value) where level is the
--- corresponding C option level constant (e.g. SOL_SOCKET) and value is
--- the option constant itself (e.g. SO_DEBUG)
--- If either constant does not exist, return Nothing.
-packSocketOption :: SocketOption -> Maybe (CInt, CInt)
-packSocketOption so =
-  -- The Just here is a hack to disable GHC's overlapping pattern detection:
-  -- the problem is if all constants are present, the fallback pattern is
-  -- redundant, but if they aren't then it isn't. Hence we introduce an
-  -- extra pattern (Nothing) that can't possibly happen, so that the
-  -- fallback is always (in principle) necessary.
-  -- I feel a little bad for including this, but such are the sacrifices we
-  -- make while working with CPP - excluding the fallback pattern correctly
-  -- would be a serious nuisance.
-  -- (NB: comments elsewhere in this file refer to this one)
-  case Just so of
-#ifdef SOL_SOCKET
-#ifdef SO_DEBUG
-    Just Debug         -> Just ((#const SOL_SOCKET), (#const SO_DEBUG))
-#endif
-#ifdef SO_REUSEADDR
-    Just ReuseAddr     -> Just ((#const SOL_SOCKET), (#const SO_REUSEADDR))
-#endif
-#ifdef SO_TYPE
-    Just Type          -> Just ((#const SOL_SOCKET), (#const SO_TYPE))
-#endif
-#ifdef SO_ERROR
-    Just SoError       -> Just ((#const SOL_SOCKET), (#const SO_ERROR))
-#endif
-#ifdef SO_DONTROUTE
-    Just DontRoute     -> Just ((#const SOL_SOCKET), (#const SO_DONTROUTE))
-#endif
-#ifdef SO_BROADCAST
-    Just Broadcast     -> Just ((#const SOL_SOCKET), (#const SO_BROADCAST))
-#endif
-#ifdef SO_SNDBUF
-    Just SendBuffer    -> Just ((#const SOL_SOCKET), (#const SO_SNDBUF))
-#endif
-#ifdef SO_RCVBUF
-    Just RecvBuffer    -> Just ((#const SOL_SOCKET), (#const SO_RCVBUF))
-#endif
-#ifdef SO_KEEPALIVE
-    Just KeepAlive     -> Just ((#const SOL_SOCKET), (#const SO_KEEPALIVE))
-#endif
-#ifdef SO_OOBINLINE
-    Just OOBInline     -> Just ((#const SOL_SOCKET), (#const SO_OOBINLINE))
-#endif
-#ifdef SO_LINGER
-    Just Linger        -> Just ((#const SOL_SOCKET), (#const SO_LINGER))
-#endif
-#ifdef SO_REUSEPORT
-    Just ReusePort     -> Just ((#const SOL_SOCKET), (#const SO_REUSEPORT))
-#endif
-#ifdef SO_RCVLOWAT
-    Just RecvLowWater  -> Just ((#const SOL_SOCKET), (#const SO_RCVLOWAT))
-#endif
-#ifdef SO_SNDLOWAT
-    Just SendLowWater  -> Just ((#const SOL_SOCKET), (#const SO_SNDLOWAT))
-#endif
-#ifdef SO_RCVTIMEO
-    Just RecvTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_RCVTIMEO))
-#endif
-#ifdef SO_SNDTIMEO
-    Just SendTimeOut   -> Just ((#const SOL_SOCKET), (#const SO_SNDTIMEO))
-#endif
-#ifdef SO_USELOOPBACK
-    Just UseLoopBack   -> Just ((#const SOL_SOCKET), (#const SO_USELOOPBACK))
-#endif
-#endif // SOL_SOCKET
-#if HAVE_DECL_IPPROTO_IP
-#ifdef IP_TTL
-    Just TimeToLive    -> Just ((#const IPPROTO_IP), (#const IP_TTL))
-#endif
-#endif // HAVE_DECL_IPPROTO_IP
-#if HAVE_DECL_IPPROTO_TCP
-#ifdef TCP_MAXSEG
-    Just MaxSegment    -> Just ((#const IPPROTO_TCP), (#const TCP_MAXSEG))
-#endif
-#ifdef TCP_NODELAY
-    Just NoDelay       -> Just ((#const IPPROTO_TCP), (#const TCP_NODELAY))
-#endif
-#ifdef TCP_USER_TIMEOUT
-    Just UserTimeout   -> Just ((#const IPPROTO_TCP), (#const TCP_USER_TIMEOUT))
-#endif
-#ifdef TCP_CORK
-    Just Cork          -> Just ((#const IPPROTO_TCP), (#const TCP_CORK))
-#endif
-#endif // HAVE_DECL_IPPROTO_TCP
-#if HAVE_DECL_IPPROTO_IPV6
-#if HAVE_DECL_IPV6_V6ONLY
-    Just IPv6Only      -> Just ((#const IPPROTO_IPV6), (#const IPV6_V6ONLY))
-#endif
-#endif // HAVE_DECL_IPPROTO_IPV6
-    Just (CustomSockOpt opt) -> Just opt
-    _             -> Nothing
-
--- | Return the option level and option value if they exist,
--- otherwise throw an error that begins "Network.Socket." ++ the String
--- parameter
-packSocketOption' :: String -> SocketOption -> IO (CInt, CInt)
-packSocketOption' caller so = maybe err return (packSocketOption so)
- where
-  err = ioError . userError . concat $ ["Network.Socket.", caller,
-    ": socket option ", show so, " unsupported on this system"]
-
--- | Set a socket option that expects an Int value.
--- There is currently no API to set e.g. the timeval socket options
-setSocketOption :: Socket
-                -> SocketOption -- Option Name
-                -> Int          -- Option Value
-                -> IO ()
-setSocketOption (MkSocket s _ _ _ _) so v = do
-   (level, opt) <- packSocketOption' "setSocketOption" so
-   with (fromIntegral v) $ \ptr_v -> do
-   throwSocketErrorIfMinus1_ "setSocketOption" $
-       c_setsockopt s level opt ptr_v
-          (fromIntegral (sizeOf (undefined :: CInt)))
-   return ()
-
-
--- | Get a socket option that gives an Int value.
--- There is currently no API to get e.g. the timeval socket options
-getSocketOption :: Socket
-                -> SocketOption  -- Option Name
-                -> IO Int        -- Option Value
-getSocketOption (MkSocket s _ _ _ _) so = do
-   (level, opt) <- packSocketOption' "getSocketOption" so
-   alloca $ \ptr_v ->
-     with (fromIntegral (sizeOf (undefined :: CInt))) $ \ptr_sz -> do
-       throwSocketErrorIfMinus1Retry_ "getSocketOption" $
-         c_getsockopt s level opt ptr_v ptr_sz
-       fromIntegral `liftM` peek ptr_v
-
-
-#if defined(HAVE_STRUCT_UCRED) || defined(HAVE_GETPEEREID)
--- | Returns the processID, userID and groupID of the socket's peer.
---
--- Only available on platforms that support SO_PEERCRED or GETPEEREID(3)
--- on domain sockets.
--- GETPEEREID(3) returns userID and groupID. processID is always 0.
-getPeerCred :: Socket -> IO (CUInt, CUInt, CUInt)
-getPeerCred sock = do
-#ifdef HAVE_STRUCT_UCRED
-  let fd = fdSocket sock
-  let sz = (#const sizeof(struct ucred))
-  allocaBytes sz $ \ ptr_cr ->
-   with (fromIntegral sz) $ \ ptr_sz -> do
-     _ <- ($) throwSocketErrorIfMinus1Retry "getPeerCred" $
-       c_getsockopt fd (#const SOL_SOCKET) (#const SO_PEERCRED) ptr_cr ptr_sz
-     pid <- (#peek struct ucred, pid) ptr_cr
-     uid <- (#peek struct ucred, uid) ptr_cr
-     gid <- (#peek struct ucred, gid) ptr_cr
-     return (pid, uid, gid)
-#else
-  (uid,gid) <- getPeerEid sock
-  return (0,uid,gid)
-#endif
-
-#ifdef HAVE_GETPEEREID
--- | The getpeereid() function returns the effective user and group IDs of the
--- peer connected to a UNIX-domain socket
-getPeerEid :: Socket -> IO (CUInt, CUInt)
-getPeerEid sock = do
-  let fd = fdSocket sock
-  alloca $ \ ptr_uid ->
-    alloca $ \ ptr_gid -> do
-      throwSocketErrorIfMinus1Retry_ "getPeerEid" $
-        c_getpeereid fd ptr_uid ptr_gid
-      uid <- peek ptr_uid
-      gid <- peek ptr_gid
-      return (uid, gid)
-#endif
-#endif
-
-##if !(MIN_VERSION_base(4,3,1))
-closeFdWith closer fd = closer fd
-##endif
-
-#if defined(DOMAIN_SOCKET_SUPPORT)
--- sending/receiving ancillary socket data; low-level mechanism
--- for transmitting file descriptors, mainly.
-sendFd :: Socket -> CInt -> IO ()
-sendFd sock outfd = do
-  _ <- ($) throwSocketErrorWaitWrite sock "sendFd" $
-     c_sendFd (fdSocket sock) outfd
-   -- Note: If Winsock supported FD-passing, thi would have been
-   -- incorrect (since socket FDs need to be closed via closesocket().)
-  closeFd outfd
-
-recvFd :: Socket -> IO CInt
-recvFd sock = do
-  theFd <- throwSocketErrorWaitRead sock "recvFd" $
-               c_recvFd (fdSocket sock)
-  return theFd
-
-foreign import ccall SAFE_ON_WIN "sendFd" c_sendFd :: CInt -> CInt -> IO CInt
-foreign import ccall SAFE_ON_WIN "recvFd" c_recvFd :: CInt -> IO CInt
-
-#endif
-
--- ---------------------------------------------------------------------------
--- Utility Functions
-
-aNY_PORT :: PortNumber
-aNY_PORT = 0
-
--- | The IPv4 wild card address.
-
-iNADDR_ANY :: HostAddress
-iNADDR_ANY = htonl (#const INADDR_ANY)
-
--- | Converts the from host byte order to network byte order.
-foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
--- | Converts the from network byte order to host byte order.
-foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
-
-#if defined(IPV6_SOCKET_SUPPORT)
--- | The IPv6 wild card address.
-
-iN6ADDR_ANY :: HostAddress6
-iN6ADDR_ANY = (0, 0, 0, 0)
-#endif
-
-sOMAXCONN :: Int
-sOMAXCONN = #const SOMAXCONN
-
-sOL_SOCKET :: Int
-sOL_SOCKET = #const SOL_SOCKET
-
-#ifdef SCM_RIGHTS
-sCM_RIGHTS :: Int
-sCM_RIGHTS = #const SCM_RIGHTS
-#endif
-
--- | This is the value of SOMAXCONN, typically 128.
--- 128 is good enough for normal network servers but
--- is too small for high performance servers.
-maxListenQueue :: Int
-maxListenQueue = sOMAXCONN
-
--- -----------------------------------------------------------------------------
-
-data ShutdownCmd
- = ShutdownReceive
- | ShutdownSend
- | ShutdownBoth
- deriving Typeable
-
-sdownCmdToInt :: ShutdownCmd -> CInt
-sdownCmdToInt ShutdownReceive = 0
-sdownCmdToInt ShutdownSend    = 1
-sdownCmdToInt ShutdownBoth    = 2
-
--- | Shut down one or both halves of the connection, depending on the
--- second argument to the function.  If the second argument is
--- 'ShutdownReceive', further receives are disallowed.  If it is
--- 'ShutdownSend', further sends are disallowed.  If it is
--- 'ShutdownBoth', further sends and receives are disallowed.
-shutdown :: Socket -> ShutdownCmd -> IO ()
-shutdown (MkSocket s _ _ _ _) stype = do
-  throwSocketErrorIfMinus1Retry_ "shutdown" (c_shutdown s (sdownCmdToInt stype))
-  return ()
-
--- -----------------------------------------------------------------------------
-
--- | Close the socket. Sending data to or receiving data from closed socket
--- may lead to undefined behaviour.
-close :: Socket -> IO ()
-close (MkSocket s _ _ _ socketStatus) = do
- modifyMVar_ socketStatus $ \ status ->
-   case status of
-     ConvertedToHandle ->
-         ioError (userError ("close: converted to a Handle, use hClose instead"))
-     Closed ->
-         return status
-     _ -> closeFdWith (closeFd . fromIntegral) (fromIntegral s) >> return Closed
-
--- -----------------------------------------------------------------------------
-
--- | Determines whether 'close' has been used on the 'Socket'. This
--- does /not/ indicate any status about the socket beyond this. If the
--- socket has been closed remotely, this function can still return
--- 'True'.
-isConnected :: Socket -> IO Bool
-isConnected (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Connected)
-
--- -----------------------------------------------------------------------------
--- Socket Predicates
-
-isBound :: Socket -> IO Bool
-isBound (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Bound)
-
-isListening :: Socket -> IO Bool
-isListening (MkSocket _ _ _  _ status) = do
-    value <- readMVar status
-    return (value == Listening)
-
-isReadable  :: Socket -> IO Bool
-isReadable (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Listening || value == Connected)
-
-isWritable  :: Socket -> IO Bool
-isWritable = isReadable -- sort of.
-
-isAcceptable :: Socket -> IO Bool
-#if defined(DOMAIN_SOCKET_SUPPORT)
-isAcceptable (MkSocket _ AF_UNIX x _ status)
-    | x == Stream || x == SeqPacket = do
-        value <- readMVar status
-        return (value == Connected || value == Bound || value == Listening)
-isAcceptable (MkSocket _ AF_UNIX _ _ _) = return False
-#endif
-isAcceptable (MkSocket _ _ _ _ status) = do
-    value <- readMVar status
-    return (value == Connected || value == Listening)
-
--- -----------------------------------------------------------------------------
--- Internet address manipulation routines:
-
-inet_addr :: String -> IO HostAddress
-inet_addr ipstr = withSocketsDo $ do
-   withCString ipstr $ \str -> do
-   had <- c_inet_addr str
-   if had == -1
-    then ioError (userError ("inet_addr: Malformed address: " ++ ipstr))
-    else return had  -- network byte order
-
-inet_ntoa :: HostAddress -> IO String
-inet_ntoa haddr = withSocketsDo $ do
-  pstr <- c_inet_ntoa haddr
-  peekCString pstr
-
--- | Turns a Socket into an 'Handle'. By default, the new handle is
--- unbuffered. Use 'System.IO.hSetBuffering' to change the buffering.
---
--- Note that since a 'Handle' is automatically closed by a finalizer
--- when it is no longer referenced, you should avoid doing any more
--- operations on the 'Socket' after calling 'socketToHandle'.  To
--- close the 'Socket' after 'socketToHandle', call 'System.IO.hClose'
--- on the 'Handle'.
-
-socketToHandle :: Socket -> IOMode -> IO Handle
-socketToHandle s@(MkSocket fd _ _ _ socketStatus) mode = do
- modifyMVar socketStatus $ \ status ->
-    if status == ConvertedToHandle
-        then ioError (userError ("socketToHandle: already a Handle"))
-        else do
-    h <- fdToHandle' (fromIntegral fd) (Just GHC.IO.Device.Stream) True (show s) mode True{-bin-}
-    hSetBuffering h NoBuffering
-    return (ConvertedToHandle, h)
-
--- | Pack a list of values into a bitmask.  The possible mappings from
--- value to bit-to-set are given as the first argument.  We assume
--- that each value can cause exactly one bit to be set; unpackBits will
--- break if this property is not true.
-
-packBits :: (Eq a, Num b, Bits b) => [(a, b)] -> [a] -> b
-
-packBits mapping xs = foldl' pack 0 mapping
-    where pack acc (k, v) | k `elem` xs = acc .|. v
-                          | otherwise   = acc
-
--- | Unpack a bitmask into a list of values.
-
-unpackBits :: (Num b, Bits b) => [(a, b)] -> b -> [a]
-
--- Be permissive and ignore unknown bit values. At least on OS X,
--- getaddrinfo returns an ai_flags field with bits set that have no
--- entry in <netdb.h>.
-unpackBits [] _    = []
-unpackBits ((k,v):xs) r
-    | r .&. v /= 0 = k : unpackBits xs (r .&. complement v)
-    | otherwise    = unpackBits xs r
-
------------------------------------------------------------------------------
--- Address and service lookups
-
-#if defined(IPV6_SOCKET_SUPPORT)
-
--- | Flags that control the querying behaviour of 'getAddrInfo'.
---   For more information, see <https://tools.ietf.org/html/rfc3493#page-25>
-data AddrInfoFlag =
-    -- | The list of returned 'AddrInfo' values will
-    --   only contain IPv4 addresses if the local system has at least
-    --   one IPv4 interface configured, and likewise for IPv6.
-    --   (Only some platforms support this.)
-      AI_ADDRCONFIG
-    -- | If 'AI_ALL' is specified, return all matching IPv6 and
-    --   IPv4 addresses.  Otherwise, this flag has no effect.
-    --   (Only some platforms support this.)
-    | AI_ALL
-    -- | The 'addrCanonName' field of the first returned
-    --   'AddrInfo' will contain the "canonical name" of the host.
-    | AI_CANONNAME
-    -- | The 'HostName' argument /must/ be a numeric
-    --   address in string form, and network name lookups will not be
-    --   attempted.
-    | AI_NUMERICHOST
-    -- | The 'ServiceName' argument /must/ be a port
-    --   number in string form, and service name lookups will not be
-    --   attempted. (Only some platforms support this.)
-    | AI_NUMERICSERV
-    -- | If no 'HostName' value is provided, the network
-    --   address in each 'SockAddr'
-    --   will be left as a "wild card", i.e. as either 'iNADDR_ANY'
-    --   or 'iN6ADDR_ANY'.  This is useful for server applications that
-    --   will accept connections from any client.
-    | AI_PASSIVE
-    -- | If an IPv6 lookup is performed, and no IPv6
-    --   addresses are found, IPv6-mapped IPv4 addresses will be
-    --   returned. (Only some platforms support this.)
-    | AI_V4MAPPED
-    deriving (Eq, Read, Show, Typeable)
-
-aiFlagMapping :: [(AddrInfoFlag, CInt)]
-
-aiFlagMapping =
-    [
-#if HAVE_DECL_AI_ADDRCONFIG
-     (AI_ADDRCONFIG, #const AI_ADDRCONFIG),
-#else
-     (AI_ADDRCONFIG, 0),
-#endif
-#if HAVE_DECL_AI_ALL
-     (AI_ALL, #const AI_ALL),
-#else
-     (AI_ALL, 0),
-#endif
-     (AI_CANONNAME, #const AI_CANONNAME),
-     (AI_NUMERICHOST, #const AI_NUMERICHOST),
-#if HAVE_DECL_AI_NUMERICSERV
-     (AI_NUMERICSERV, #const AI_NUMERICSERV),
-#else
-     (AI_NUMERICSERV, 0),
-#endif
-     (AI_PASSIVE, #const AI_PASSIVE),
-#if HAVE_DECL_AI_V4MAPPED
-     (AI_V4MAPPED, #const AI_V4MAPPED)
-#else
-     (AI_V4MAPPED, 0)
-#endif
-    ]
-
--- | Indicate whether the given 'AddrInfoFlag' will have any effect on
--- this system.
-addrInfoFlagImplemented :: AddrInfoFlag -> Bool
-addrInfoFlagImplemented f = packBits aiFlagMapping [f] /= 0
-
-data AddrInfo =
-    AddrInfo {
-        addrFlags :: [AddrInfoFlag],
-        addrFamily :: Family,
-        addrSocketType :: SocketType,
-        addrProtocol :: ProtocolNumber,
-        addrAddress :: SockAddr,
-        addrCanonName :: Maybe String
-        }
-    deriving (Eq, Show, Typeable)
-
-instance Storable AddrInfo where
-    sizeOf    _ = #const sizeof(struct addrinfo)
-    alignment _ = alignment (undefined :: CInt)
-
-    peek p = do
-        ai_flags <- (#peek struct addrinfo, ai_flags) p
-        ai_family <- (#peek struct addrinfo, ai_family) p
-        ai_socktype <- (#peek struct addrinfo, ai_socktype) p
-        ai_protocol <- (#peek struct addrinfo, ai_protocol) p
-        ai_addr <- (#peek struct addrinfo, ai_addr) p >>= peekSockAddr
-        ai_canonname_ptr <- (#peek struct addrinfo, ai_canonname) p
-
-        ai_canonname <- if ai_canonname_ptr == nullPtr
-                        then return Nothing
-                        else liftM Just $ peekCString ai_canonname_ptr
-
-        socktype <- unpackSocketType' "AddrInfo.peek" ai_socktype
-        return (AddrInfo
-                {
-                 addrFlags = unpackBits aiFlagMapping ai_flags,
-                 addrFamily = unpackFamily ai_family,
-                 addrSocketType = socktype,
-                 addrProtocol = ai_protocol,
-                 addrAddress = ai_addr,
-                 addrCanonName = ai_canonname
-                })
-
-    poke p (AddrInfo flags family socketType protocol _ _) = do
-        c_stype <- packSocketTypeOrThrow "AddrInfo.poke" socketType
-
-        (#poke struct addrinfo, ai_flags) p (packBits aiFlagMapping flags)
-        (#poke struct addrinfo, ai_family) p (packFamily family)
-        (#poke struct addrinfo, ai_socktype) p c_stype
-        (#poke struct addrinfo, ai_protocol) p protocol
-
-        -- stuff below is probably not needed, but let's zero it for safety
-
-        (#poke struct addrinfo, ai_addrlen) p (0::CSize)
-        (#poke struct addrinfo, ai_addr) p nullPtr
-        (#poke struct addrinfo, ai_canonname) p nullPtr
-        (#poke struct addrinfo, ai_next) p nullPtr
-
--- | Flags that control the querying behaviour of 'getNameInfo'.
---   For more information, see <https://tools.ietf.org/html/rfc3493#page-30>
-data NameInfoFlag =
-    -- | Resolve a datagram-based service name.  This is
-    --   required only for the few protocols that have different port
-    --   numbers for their datagram-based versions than for their
-    --   stream-based versions.
-      NI_DGRAM
-    -- | If the hostname cannot be looked up, an IO error is thrown.
-    | NI_NAMEREQD
-    -- | If a host is local, return only the hostname part of the FQDN.
-    | NI_NOFQDN
-    -- | The name of the host is not looked up.
-    --   Instead, a numeric representation of the host's
-    --   address is returned.  For an IPv4 address, this will be a
-    --   dotted-quad string.  For IPv6, it will be colon-separated
-    --   hexadecimal.
-    | NI_NUMERICHOST
-    -- | The name of the service is not
-    --   looked up.  Instead, a numeric representation of the
-    --   service is returned.
-    | NI_NUMERICSERV
-    deriving (Eq, Read, Show, Typeable)
-
-niFlagMapping :: [(NameInfoFlag, CInt)]
-
-niFlagMapping = [(NI_DGRAM, #const NI_DGRAM),
-                 (NI_NAMEREQD, #const NI_NAMEREQD),
-                 (NI_NOFQDN, #const NI_NOFQDN),
-                 (NI_NUMERICHOST, #const NI_NUMERICHOST),
-                 (NI_NUMERICSERV, #const NI_NUMERICSERV)]
-
--- | Default hints for address lookup with 'getAddrInfo'.  The values
--- of the 'addrAddress' and 'addrCanonName' fields are 'undefined',
--- and are never inspected by 'getAddrInfo'.
---
--- >>> addrFlags defaultHints
--- []
--- >>> addrFamily defaultHints
--- AF_UNSPEC
--- >>> addrSocketType defaultHints
--- NoSocketType
--- >>> addrProtocol defaultHints
--- 0
-
-defaultHints :: AddrInfo
-defaultHints = AddrInfo {
-                         addrFlags = [],
-                         addrFamily = AF_UNSPEC,
-                         addrSocketType = NoSocketType,
-                         addrProtocol = defaultProtocol,
-                         addrAddress = undefined,
-                         addrCanonName = undefined
-                        }
-
--- | Resolve a host or service name to one or more addresses.
--- The 'AddrInfo' values that this function returns contain 'SockAddr'
--- values that you can pass directly to 'connect' or
--- 'bind'.
---
--- This function is protocol independent.  It can return both IPv4 and
--- IPv6 address information.
---
--- The 'AddrInfo' argument specifies the preferred query behaviour,
--- socket options, or protocol.  You can override these conveniently
--- using Haskell's record update syntax on 'defaultHints', for example
--- as follows:
---
--- >>> let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
---
--- You must provide a 'Just' value for at least one of the 'HostName'
--- or 'ServiceName' arguments.  'HostName' can be either a numeric
--- network address (dotted quad for IPv4, colon-separated hex for
--- IPv6) or a hostname.  In the latter case, its addresses will be
--- looked up unless 'AI_NUMERICHOST' is specified as a hint.  If you
--- do not provide a 'HostName' value /and/ do not set 'AI_PASSIVE' as
--- a hint, network addresses in the result will contain the address of
--- the loopback interface.
---
--- If the query fails, this function throws an IO exception instead of
--- returning an empty list.  Otherwise, it returns a non-empty list
--- of 'AddrInfo' values.
---
--- There are several reasons why a query might result in several
--- values.  For example, the queried-for host could be multihomed, or
--- the service might be available via several protocols.
---
--- Note: the order of arguments is slightly different to that defined
--- for @getaddrinfo@ in RFC 2553.  The 'AddrInfo' parameter comes first
--- to make partial application easier.
---
--- >>> addr:_ <- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
--- >>> addrAddress addr
--- 127.0.0.1:80
-
-getAddrInfo :: Maybe AddrInfo -- ^ preferred socket type or protocol
-            -> Maybe HostName -- ^ host name to look up
-            -> Maybe ServiceName -- ^ service name to look up
-            -> IO [AddrInfo] -- ^ resolved addresses, with "best" first
-
-getAddrInfo hints node service = withSocketsDo $
-  maybeWith withCString node $ \c_node ->
-    maybeWith withCString service $ \c_service ->
-      maybeWith with filteredHints $ \c_hints ->
-        alloca $ \ptr_ptr_addrs -> do
-          ret <- c_getaddrinfo c_node c_service c_hints ptr_ptr_addrs
-          case ret of
-            0 -> do ptr_addrs <- peek ptr_ptr_addrs
-                    ais <- followAddrInfo ptr_addrs
-                    c_freeaddrinfo ptr_addrs
-                    return ais
-            _ -> do err <- gai_strerror ret
-                    ioError (ioeSetErrorString
-                             (mkIOError NoSuchThing "getAddrInfo" Nothing
-                              Nothing) err)
-    -- Leaving out the service and using AI_NUMERICSERV causes a
-    -- segfault on OS X 10.8.2. This code removes AI_NUMERICSERV
-    -- (which has no effect) in that case.
-  where
-#if defined(darwin_HOST_OS)
-    filteredHints = case service of
-        Nothing -> fmap (\ h -> h { addrFlags = delete AI_NUMERICSERV (addrFlags h) }) hints
-        _       -> hints
-#else
-    filteredHints = hints
-#endif
-
-followAddrInfo :: Ptr AddrInfo -> IO [AddrInfo]
-
-followAddrInfo ptr_ai | ptr_ai == nullPtr = return []
-                      | otherwise = do
-    a <- peek ptr_ai
-    as <- (#peek struct addrinfo, ai_next) ptr_ai >>= followAddrInfo
-    return (a:as)
-
-foreign import ccall safe "hsnet_getaddrinfo"
-    c_getaddrinfo :: CString -> CString -> Ptr AddrInfo -> Ptr (Ptr AddrInfo)
-                  -> IO CInt
-
-foreign import ccall safe "hsnet_freeaddrinfo"
-    c_freeaddrinfo :: Ptr AddrInfo -> IO ()
-
-gai_strerror :: CInt -> IO String
-
-#ifdef HAVE_GAI_STRERROR
-gai_strerror n = c_gai_strerror n >>= peekCString
-
-foreign import ccall safe "gai_strerror"
-    c_gai_strerror :: CInt -> IO CString
-#else
-gai_strerror n = return ("error " ++ show n)
-#endif
-
-withCStringIf :: Bool -> Int -> (CSize -> CString -> IO a) -> IO a
-withCStringIf False _ f = f 0 nullPtr
-withCStringIf True n f = allocaBytes n (f (fromIntegral n))
-
--- | Resolve an address to a host or service name.
--- This function is protocol independent.
--- The list of 'NameInfoFlag' values controls query behaviour.
---
--- If a host or service's name cannot be looked up, then the numeric
--- form of the address or service will be returned.
---
--- If the query fails, this function throws an IO exception.
---
--- Example:
--- @
---   (hostName, _) <- getNameInfo [] True False myAddress
--- @
-
-getNameInfo :: [NameInfoFlag] -- ^ flags to control lookup behaviour
-            -> Bool -- ^ whether to look up a hostname
-            -> Bool -- ^ whether to look up a service name
-            -> SockAddr -- ^ the address to look up
-            -> IO (Maybe HostName, Maybe ServiceName)
-
-getNameInfo flags doHost doService addr = withSocketsDo $
-  withCStringIf doHost (#const NI_MAXHOST) $ \c_hostlen c_host ->
-    withCStringIf doService (#const NI_MAXSERV) $ \c_servlen c_serv -> do
-      withSockAddr addr $ \ptr_addr sz -> do
-        ret <- c_getnameinfo ptr_addr (fromIntegral sz) c_host c_hostlen
-                             c_serv c_servlen (packBits niFlagMapping flags)
-        case ret of
-          0 -> do
-            let peekIf doIf c_val = if doIf
-                                     then liftM Just $ peekCString c_val
-                                     else return Nothing
-            host <- peekIf doHost c_host
-            serv <- peekIf doService c_serv
-            return (host, serv)
-          _ -> do err <- gai_strerror ret
-                  ioError (ioeSetErrorString
-                           (mkIOError NoSuchThing "getNameInfo" Nothing
-                            Nothing) err)
-
-foreign import ccall safe "hsnet_getnameinfo"
-    c_getnameinfo :: Ptr SockAddr -> CInt{-CSockLen???-} -> CString -> CSize -> CString
-                  -> CSize -> CInt -> IO CInt
-#endif
-
-mkInvalidRecvArgError :: String -> IOError
-mkInvalidRecvArgError loc = ioeSetErrorString (mkIOError
-                                    InvalidArgument
-                                    loc Nothing Nothing) "non-positive length"
-
-mkEOFError :: String -> IOError
-mkEOFError loc = ioeSetErrorString (mkIOError EOF loc Nothing Nothing) "end of file"
-
--- ---------------------------------------------------------------------------
--- foreign imports from the C library
-
-foreign import ccall unsafe "my_inet_ntoa"
-  c_inet_ntoa :: HostAddress -> IO (Ptr CChar)
-
-foreign import CALLCONV unsafe "inet_addr"
-  c_inet_addr :: Ptr CChar -> IO HostAddress
-
-foreign import CALLCONV unsafe "shutdown"
-  c_shutdown :: CInt -> CInt -> IO CInt
-
-closeFd :: CInt -> IO ()
-closeFd fd = throwSocketErrorIfMinus1_ "Network.Socket.close" $ c_close fd
-
-#if !defined(WITH_WINSOCK)
-foreign import ccall unsafe "close"
-  c_close :: CInt -> IO CInt
-#else
-foreign import stdcall unsafe "closesocket"
-  c_close :: CInt -> IO CInt
-#endif
-
-foreign import CALLCONV unsafe "socket"
-  c_socket :: CInt -> CInt -> CInt -> IO CInt
-foreign import CALLCONV unsafe "bind"
-  c_bind :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "connect"
-  c_connect :: CInt -> Ptr SockAddr -> CInt{-CSockLen???-} -> IO CInt
-#ifdef HAVE_ACCEPT4
-foreign import CALLCONV unsafe "accept4"
-  c_accept4 :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> CInt -> IO CInt
-#else
-foreign import CALLCONV unsafe "accept"
-  c_accept :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
-#endif
-foreign import CALLCONV unsafe "listen"
-  c_listen :: CInt -> CInt -> IO CInt
-
-#if defined(mingw32_HOST_OS)
-foreign import CALLCONV safe "accept"
-  c_accept_safe :: CInt -> Ptr SockAddr -> Ptr CInt{-CSockLen???-} -> IO CInt
-
-foreign import ccall unsafe "rtsSupportsBoundThreads" threaded :: Bool
-#endif
-
-foreign import CALLCONV unsafe "send"
-  c_send :: CInt -> Ptr a -> CSize -> CInt -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "sendto"
-  c_sendto :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> CInt -> IO CInt
-foreign import CALLCONV unsafe "recv"
-  c_recv :: CInt -> Ptr CChar -> CSize -> CInt -> IO CInt
-foreign import CALLCONV SAFE_ON_WIN "recvfrom"
-  c_recvfrom :: CInt -> Ptr a -> CSize -> CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "getpeername"
-  c_getpeername :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "getsockname"
-  c_getsockname :: CInt -> Ptr SockAddr -> Ptr CInt -> IO CInt
-
-foreign import CALLCONV unsafe "getsockopt"
-  c_getsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> Ptr CInt -> IO CInt
-foreign import CALLCONV unsafe "setsockopt"
-  c_setsockopt :: CInt -> CInt -> CInt -> Ptr CInt -> CInt -> IO CInt
-
-#if defined(HAVE_GETPEEREID)
-foreign import CALLCONV unsafe "getpeereid"
-  c_getpeereid :: CInt -> Ptr CUInt -> Ptr CUInt -> IO CInt
-#endif
--- ---------------------------------------------------------------------------
--- * Deprecated aliases
-
--- $deprecated-aliases
---
--- These aliases are deprecated and should not be used in new code.
--- They will be removed in some future version of the package.
-
-{-# DEPRECATED bindSocket "use 'bind'" #-}
-
--- | Deprecated alias for 'bind'.
-bindSocket :: Socket    -- Unconnected Socket
-           -> SockAddr  -- Address to Bind to
-           -> IO ()
-bindSocket = bind
-
-{-# DEPRECATED sClose "use 'close'" #-}
-
--- | Deprecated alias for 'close'.
-sClose :: Socket -> IO ()
-sClose = close
-
-{-# DEPRECATED sIsConnected "use 'isConnected'" #-}
-
--- | Deprecated alias for 'isConnected'.
-sIsConnected :: Socket -> IO Bool
-sIsConnected = isConnected
-
-{-# DEPRECATED sIsBound "use 'isBound'" #-}
-
--- | Deprecated alias for 'isBound'.
-sIsBound :: Socket -> IO Bool
-sIsBound = isBound
-
-{-# DEPRECATED sIsListening "use 'isListening'" #-}
-
--- | Deprecated alias for 'isListening'.
-sIsListening :: Socket -> IO Bool
-sIsListening = isListening
-
-{-# DEPRECATED sIsReadable "use 'isReadable'" #-}
-
--- | Deprecated alias for 'isReadable'.
-sIsReadable  :: Socket -> IO Bool
-sIsReadable = isReadable
-
-{-# DEPRECATED sIsWritable "use 'isWritable'" #-}
-
--- | Deprecated alias for 'isWritable'.
-sIsWritable  :: Socket -> IO Bool
-sIsWritable = isWritable
diff --git a/Network/Socket/Types.hs b/Network/Socket/Types.hs
new file mode 100644
index 0000000..1918a0a
--- /dev/null
+++ b/Network/Socket/Types.hs
@@ -0,0 +1,1104 @@
+{-# LANGUAGE DeriveDataTypeable #-}
+{-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE ForeignFunctionInterface #-}
+
+-- #include "HsNet.h"
+
+module Network.Socket.Types
+    (
+    -- -- * Socket
+    --   Socket(..)
+    -- , sockFd
+    -- , sockFamily
+    -- , sockType
+    -- , sockProtocol
+    -- , sockStatus
+    -- , SocketStatus(..)
+
+    -- -- * Socket types
+    -- , SocketType(..)
+    -- , isSupportedSocketType
+    -- , packSocketType
+    -- , packSocketType'
+    -- , packSocketTypeOrThrow
+    -- , unpackSocketType
+    -- , unpackSocketType'
+
+    -- -- * Family
+    -- , Family(..)
+    -- , isSupportedFamily
+    -- , packFamily
+    -- , unpackFamily
+
+    -- * Socket addresses
+    -- ,
+    SockAddr(..)
+    -- , isSupportedSockAddr
+    , HostAddress
+--     , hostAddressToTuple
+--     , tupleToHostAddress
+-- #if defined(IPV6_SOCKET_SUPPORT)
+    , HostAddress6
+    -- , hostAddress6ToTuple
+    -- , tupleToHostAddress6
+    , FlowInfo
+    , ScopeID
+-- #endif
+    -- , peekSockAddr
+    -- , pokeSockAddr
+    -- , sizeOfSockAddr
+    -- , sizeOfSockAddrByFamily
+    -- , withSockAddr
+    -- , withNewSockAddr
+
+    -- * Unsorted
+    -- , ProtocolNumber
+    , PortNumber(..)
+
+    -- * Low-level helpers
+    -- , zeroMemory
+    ) where
+
+-- import Control.Concurrent.MVar
+-- import Control.Exception (throwIO)
+import Control.Monad
+-- import Data.Bits
+-- import Data.Maybe
+import Data.Ratio
+import Data.Typeable
+import Data.Word
+import Data.Int
+-- import Foreign.C
+-- import Foreign.Marshal.Alloc
+-- import Foreign.Marshal.Array
+import Foreign.Ptr
+import Foreign.Storable
+
+-- | Represents a socket.  The fields are, respectively:
+--
+--   * File descriptor
+--   * Socket family
+--   * Socket type
+--   * Protocol number
+--   * Status flag
+--
+--   If you are calling the 'MkSocket' constructor directly you should ensure
+--   you have called 'Network.withSocketsDo'.
+-- data Socket
+--   = MkSocket
+--             CInt                 -- File Descriptor
+--             Family
+--             SocketType
+--             ProtocolNumber       -- Protocol Number
+--             (MVar SocketStatus)  -- Status Flag
+--   deriving Typeable
+
+-- sockFd :: Socket -> CInt
+-- sockFd       (MkSocket n _ _ _ _) = n
+
+-- sockFamily :: Socket -> Family
+-- sockFamily   (MkSocket _ f _ _ _) = f
+
+-- sockType :: Socket -> SocketType
+-- sockType     (MkSocket _ _ t _ _) = t
+
+-- sockProtocol :: Socket -> ProtocolNumber
+-- sockProtocol (MkSocket _ _ _ p _) = p
+
+-- sockStatus :: Socket -> MVar SocketStatus
+-- sockStatus   (MkSocket _ _ _ _ s) = s
+
+-- instance Eq Socket where
+--   (MkSocket _ _ _ _ m1) == (MkSocket _ _ _ _ m2) = m1 == m2
+
+-- instance Show Socket where
+--   showsPrec _n (MkSocket fd _ _ _ _) =
+--         showString "<socket: " . shows fd . showString ">"
+
+-- type ProtocolNumber = CInt
+
+-- -- | The status of the socket as /determined by this library/, not
+-- -- necessarily reflecting the state of the connection itself.
+-- --
+-- -- For example, the 'Closed' status is applied when the 'close'
+-- -- function is called.
+-- data SocketStatus
+--   -- Returned Status    Function called
+--   = NotConnected        -- ^ Newly created, unconnected socket
+--   | Bound               -- ^ Bound, via 'bind'
+--   | Listening           -- ^ Listening, via 'listen'
+--   | Connected           -- ^ Connected or accepted, via 'connect' or 'accept'
+--   | ConvertedToHandle   -- ^ Is now a 'Handle' (via 'socketToHandle'), don't touch
+--   | Closed              -- ^ Closed was closed by 'close'
+--     deriving (Eq, Show, Typeable)
+
+-- -----------------------------------------------------------------------------
+-- -- Socket types
+
+-- -- There are a few possible ways to do this.  The first is convert the
+-- -- structs used in the C library into an equivalent Haskell type. An
+-- -- other possible implementation is to keep all the internals in the C
+-- -- code and use an Int## and a status flag. The second method is used
+-- -- here since a lot of the C structures are not required to be
+-- -- manipulated.
+
+-- -- Originally the status was non-mutable so we had to return a new
+-- -- socket each time we changed the status.  This version now uses
+-- -- mutable variables to avoid the need to do this.  The result is a
+-- -- cleaner interface and better security since the application
+-- -- programmer now can't circumvent the status information to perform
+-- -- invalid operations on sockets.
+
+-- -- | Socket Types.
+-- --
+-- -- The existence of a constructor does not necessarily imply that that
+-- -- socket type is supported on your system: see 'isSupportedSocketType'.
+-- data SocketType
+--         = NoSocketType -- ^ 0, used in getAddrInfo hints, for example
+--         | Stream -- ^ SOCK_STREAM
+--         | Datagram -- ^ SOCK_DGRAM
+--         | Raw -- ^ SOCK_RAW
+--         | RDM -- ^ SOCK_RDM
+--         | SeqPacket -- ^ SOCK_SEQPACKET
+--         deriving (Eq, Ord, Read, Show, Typeable)
+
+-- -- | Does the SOCK_ constant corresponding to the given SocketType exist on
+-- -- this system?
+-- isSupportedSocketType :: SocketType -> Bool
+-- isSupportedSocketType = isJust . packSocketType'
+
+-- -- | Find the SOCK_ constant corresponding to the SocketType value.
+-- packSocketType' :: SocketType -> Maybe CInt
+-- packSocketType' stype = case Just stype of
+--     -- the Just above is to disable GHC's overlapping pattern
+--     -- detection: see comments for packSocketOption
+--     Just NoSocketType -> Just 0
+-- #ifdef SOCK_STREAM
+--     Just Stream -> Just #const SOCK_STREAM
+-- #endif
+-- #ifdef SOCK_DGRAM
+--     Just Datagram -> Just #const SOCK_DGRAM
+-- #endif
+-- #ifdef SOCK_RAW
+--     Just Raw -> Just #const SOCK_RAW
+-- #endif
+-- #ifdef SOCK_RDM
+--     Just RDM -> Just #const SOCK_RDM
+-- #endif
+-- #ifdef SOCK_SEQPACKET
+--     Just SeqPacket -> Just #const SOCK_SEQPACKET
+-- #endif
+--     _ -> Nothing
+
+-- packSocketType :: SocketType -> CInt
+-- packSocketType stype = fromMaybe (error errMsg) (packSocketType' stype)
+--   where
+--     errMsg = concat ["Network.Socket.packSocketType: ",
+--                      "socket type ", show stype, " unsupported on this system"]
+
+-- -- | Try packSocketType' on the SocketType, if it fails throw an error with
+-- -- message starting "Network.Socket." ++ the String parameter
+-- packSocketTypeOrThrow :: String -> SocketType -> IO CInt
+-- packSocketTypeOrThrow caller stype = maybe err return (packSocketType' stype)
+--  where
+--   err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
+--     "socket type ", show stype, " unsupported on this system"]
+
+
+-- unpackSocketType:: CInt -> Maybe SocketType
+-- unpackSocketType t = case t of
+--         0 -> Just NoSocketType
+-- #ifdef SOCK_STREAM
+--         (#const SOCK_STREAM) -> Just Stream
+-- #endif
+-- #ifdef SOCK_DGRAM
+--         (#const SOCK_DGRAM) -> Just Datagram
+-- #endif
+-- #ifdef SOCK_RAW
+--         (#const SOCK_RAW) -> Just Raw
+-- #endif
+-- #ifdef SOCK_RDM
+--         (#const SOCK_RDM) -> Just RDM
+-- #endif
+-- #ifdef SOCK_SEQPACKET
+--         (#const SOCK_SEQPACKET) -> Just SeqPacket
+-- #endif
+--         _ -> Nothing
+
+-- -- | Try unpackSocketType on the CInt, if it fails throw an error with
+-- -- message starting "Network.Socket." ++ the String parameter
+-- unpackSocketType' :: String -> CInt -> IO SocketType
+-- unpackSocketType' caller ty = maybe err return (unpackSocketType ty)
+--  where
+--   err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
+--     "socket type ", show ty, " unsupported on this system"]
+
+-- ------------------------------------------------------------------------
+-- -- Protocol Families.
+
+-- -- | Address families.
+-- --
+-- -- A constructor being present here does not mean it is supported by the
+-- -- operating system: see 'isSupportedFamily'.
+-- data Family
+--     = AF_UNSPEC           -- unspecified
+--     | AF_UNIX             -- local to host (pipes, portals
+--     | AF_INET             -- internetwork: UDP, TCP, etc
+--     | AF_INET6            -- Internet Protocol version 6
+--     | AF_IMPLINK          -- arpanet imp addresses
+--     | AF_PUP              -- pup protocols: e.g. BSP
+--     | AF_CHAOS            -- mit CHAOS protocols
+--     | AF_NS               -- XEROX NS protocols
+--     | AF_NBS              -- nbs protocols
+--     | AF_ECMA             -- european computer manufacturers
+--     | AF_DATAKIT          -- datakit protocols
+--     | AF_CCITT            -- CCITT protocols, X.25 etc
+--     | AF_SNA              -- IBM SNA
+--     | AF_DECnet           -- DECnet
+--     | AF_DLI              -- Direct data link interface
+--     | AF_LAT              -- LAT
+--     | AF_HYLINK           -- NSC Hyperchannel
+--     | AF_APPLETALK        -- Apple Talk
+--     | AF_ROUTE            -- Internal Routing Protocol
+--     | AF_NETBIOS          -- NetBios-style addresses
+--     | AF_NIT              -- Network Interface Tap
+--     | AF_802              -- IEEE 802.2, also ISO 8802
+--     | AF_ISO              -- ISO protocols
+--     | AF_OSI              -- umbrella of all families used by OSI
+--     | AF_NETMAN           -- DNA Network Management
+--     | AF_X25              -- CCITT X.25
+--     | AF_AX25
+--     | AF_OSINET           -- AFI
+--     | AF_GOSSIP           -- US Government OSI
+--     | AF_IPX              -- Novell Internet Protocol
+--     | Pseudo_AF_XTP       -- eXpress Transfer Protocol (no AF)
+--     | AF_CTF              -- Common Trace Facility
+--     | AF_WAN              -- Wide Area Network protocols
+--     | AF_SDL              -- SGI Data Link for DLPI
+--     | AF_NETWARE
+--     | AF_NDD
+--     | AF_INTF             -- Debugging use only
+--     | AF_COIP             -- connection-oriented IP, aka ST II
+--     | AF_CNT              -- Computer Network Technology
+--     | Pseudo_AF_RTIP      -- Help Identify RTIP packets
+--     | Pseudo_AF_PIP       -- Help Identify PIP packets
+--     | AF_SIP              -- Simple Internet Protocol
+--     | AF_ISDN             -- Integrated Services Digital Network
+--     | Pseudo_AF_KEY       -- Internal key-management function
+--     | AF_NATM             -- native ATM access
+--     | AF_ARP              -- (rev.) addr. res. prot. (RFC 826)
+--     | Pseudo_AF_HDRCMPLT  -- Used by BPF to not rewrite hdrs in iface output
+--     | AF_ENCAP
+--     | AF_LINK             -- Link layer interface
+--     | AF_RAW              -- Link layer interface
+--     | AF_RIF              -- raw interface
+--     | AF_NETROM           -- Amateur radio NetROM
+--     | AF_BRIDGE           -- multiprotocol bridge
+--     | AF_ATMPVC           -- ATM PVCs
+--     | AF_ROSE             -- Amateur Radio X.25 PLP
+--     | AF_NETBEUI          -- 802.2LLC
+--     | AF_SECURITY         -- Security callback pseudo AF
+--     | AF_PACKET           -- Packet family
+--     | AF_ASH              -- Ash
+--     | AF_ECONET           -- Acorn Econet
+--     | AF_ATMSVC           -- ATM SVCs
+--     | AF_IRDA             -- IRDA sockets
+--     | AF_PPPOX            -- PPPoX sockets
+--     | AF_WANPIPE          -- Wanpipe API sockets
+--     | AF_BLUETOOTH        -- bluetooth sockets
+--     | AF_CAN              -- Controller Area Network
+--       deriving (Eq, Ord, Read, Show)
+
+-- packFamily :: Family -> CInt
+-- packFamily f = case packFamily' f of
+--     Just fam -> fam
+--     Nothing -> error $
+--                "Network.Socket.packFamily: unsupported address family: " ++
+--                show f
+
+-- -- | Does the AF_ constant corresponding to the given family exist on this
+-- -- system?
+-- isSupportedFamily :: Family -> Bool
+-- isSupportedFamily = isJust . packFamily'
+
+-- packFamily' :: Family -> Maybe CInt
+-- packFamily' f = case Just f of
+--     -- the Just above is to disable GHC's overlapping pattern
+--     -- detection: see comments for packSocketOption
+--     Just AF_UNSPEC -> Just #const AF_UNSPEC
+-- #ifdef AF_UNIX
+--     Just AF_UNIX -> Just #const AF_UNIX
+-- #endif
+-- #ifdef AF_INET
+--     Just AF_INET -> Just #const AF_INET
+-- #endif
+-- #ifdef AF_INET6
+--     Just AF_INET6 -> Just #const AF_INET6
+-- #endif
+-- #ifdef AF_IMPLINK
+--     Just AF_IMPLINK -> Just #const AF_IMPLINK
+-- #endif
+-- #ifdef AF_PUP
+--     Just AF_PUP -> Just #const AF_PUP
+-- #endif
+-- #ifdef AF_CHAOS
+--     Just AF_CHAOS -> Just #const AF_CHAOS
+-- #endif
+-- #ifdef AF_NS
+--     Just AF_NS -> Just #const AF_NS
+-- #endif
+-- #ifdef AF_NBS
+--     Just AF_NBS -> Just #const AF_NBS
+-- #endif
+-- #ifdef AF_ECMA
+--     Just AF_ECMA -> Just #const AF_ECMA
+-- #endif
+-- #ifdef AF_DATAKIT
+--     Just AF_DATAKIT -> Just #const AF_DATAKIT
+-- #endif
+-- #ifdef AF_CCITT
+--     Just AF_CCITT -> Just #const AF_CCITT
+-- #endif
+-- #ifdef AF_SNA
+--     Just AF_SNA -> Just #const AF_SNA
+-- #endif
+-- #ifdef AF_DECnet
+--     Just AF_DECnet -> Just #const AF_DECnet
+-- #endif
+-- #ifdef AF_DLI
+--     Just AF_DLI -> Just #const AF_DLI
+-- #endif
+-- #ifdef AF_LAT
+--     Just AF_LAT -> Just #const AF_LAT
+-- #endif
+-- #ifdef AF_HYLINK
+--     Just AF_HYLINK -> Just #const AF_HYLINK
+-- #endif
+-- #ifdef AF_APPLETALK
+--     Just AF_APPLETALK -> Just #const AF_APPLETALK
+-- #endif
+-- #ifdef AF_ROUTE
+--     Just AF_ROUTE -> Just #const AF_ROUTE
+-- #endif
+-- #ifdef AF_NETBIOS
+--     Just AF_NETBIOS -> Just #const AF_NETBIOS
+-- #endif
+-- #ifdef AF_NIT
+--     Just AF_NIT -> Just #const AF_NIT
+-- #endif
+-- #ifdef AF_802
+--     Just AF_802 -> Just #const AF_802
+-- #endif
+-- #ifdef AF_ISO
+--     Just AF_ISO -> Just #const AF_ISO
+-- #endif
+-- #ifdef AF_OSI
+--     Just AF_OSI -> Just #const AF_OSI
+-- #endif
+-- #ifdef AF_NETMAN
+--     Just AF_NETMAN -> Just #const AF_NETMAN
+-- #endif
+-- #ifdef AF_X25
+--     Just AF_X25 -> Just #const AF_X25
+-- #endif
+-- #ifdef AF_AX25
+--     Just AF_AX25 -> Just #const AF_AX25
+-- #endif
+-- #ifdef AF_OSINET
+--     Just AF_OSINET -> Just #const AF_OSINET
+-- #endif
+-- #ifdef AF_GOSSIP
+--     Just AF_GOSSIP -> Just #const AF_GOSSIP
+-- #endif
+-- #ifdef AF_IPX
+--     Just AF_IPX -> Just #const AF_IPX
+-- #endif
+-- #ifdef Pseudo_AF_XTP
+--     Just Pseudo_AF_XTP -> Just #const Pseudo_AF_XTP
+-- #endif
+-- #ifdef AF_CTF
+--     Just AF_CTF -> Just #const AF_CTF
+-- #endif
+-- #ifdef AF_WAN
+--     Just AF_WAN -> Just #const AF_WAN
+-- #endif
+-- #ifdef AF_SDL
+--     Just AF_SDL -> Just #const AF_SDL
+-- #endif
+-- #ifdef AF_NETWARE
+--     Just AF_NETWARE -> Just #const AF_NETWARE
+-- #endif
+-- #ifdef AF_NDD
+--     Just AF_NDD -> Just #const AF_NDD
+-- #endif
+-- #ifdef AF_INTF
+--     Just AF_INTF -> Just #const AF_INTF
+-- #endif
+-- #ifdef AF_COIP
+--     Just AF_COIP -> Just #const AF_COIP
+-- #endif
+-- #ifdef AF_CNT
+--     Just AF_CNT -> Just #const AF_CNT
+-- #endif
+-- #ifdef Pseudo_AF_RTIP
+--     Just Pseudo_AF_RTIP -> Just #const Pseudo_AF_RTIP
+-- #endif
+-- #ifdef Pseudo_AF_PIP
+--     Just Pseudo_AF_PIP -> Just #const Pseudo_AF_PIP
+-- #endif
+-- #ifdef AF_SIP
+--     Just AF_SIP -> Just #const AF_SIP
+-- #endif
+-- #ifdef AF_ISDN
+--     Just AF_ISDN -> Just #const AF_ISDN
+-- #endif
+-- #ifdef Pseudo_AF_KEY
+--     Just Pseudo_AF_KEY -> Just #const Pseudo_AF_KEY
+-- #endif
+-- #ifdef AF_NATM
+--     Just AF_NATM -> Just #const AF_NATM
+-- #endif
+-- #ifdef AF_ARP
+--     Just AF_ARP -> Just #const AF_ARP
+-- #endif
+-- #ifdef Pseudo_AF_HDRCMPLT
+--     Just Pseudo_AF_HDRCMPLT -> Just #const Pseudo_AF_HDRCMPLT
+-- #endif
+-- #ifdef AF_ENCAP
+--     Just AF_ENCAP -> Just #const AF_ENCAP
+-- #endif
+-- #ifdef AF_LINK
+--     Just AF_LINK -> Just #const AF_LINK
+-- #endif
+-- #ifdef AF_RAW
+--     Just AF_RAW -> Just #const AF_RAW
+-- #endif
+-- #ifdef AF_RIF
+--     Just AF_RIF -> Just #const AF_RIF
+-- #endif
+-- #ifdef AF_NETROM
+--     Just AF_NETROM -> Just #const AF_NETROM
+-- #endif
+-- #ifdef AF_BRIDGE
+--     Just AF_BRIDGE -> Just #const AF_BRIDGE
+-- #endif
+-- #ifdef AF_ATMPVC
+--     Just AF_ATMPVC -> Just #const AF_ATMPVC
+-- #endif
+-- #ifdef AF_ROSE
+--     Just AF_ROSE -> Just #const AF_ROSE
+-- #endif
+-- #ifdef AF_NETBEUI
+--     Just AF_NETBEUI -> Just #const AF_NETBEUI
+-- #endif
+-- #ifdef AF_SECURITY
+--     Just AF_SECURITY -> Just #const AF_SECURITY
+-- #endif
+-- #ifdef AF_PACKET
+--     Just AF_PACKET -> Just #const AF_PACKET
+-- #endif
+-- #ifdef AF_ASH
+--     Just AF_ASH -> Just #const AF_ASH
+-- #endif
+-- #ifdef AF_ECONET
+--     Just AF_ECONET -> Just #const AF_ECONET
+-- #endif
+-- #ifdef AF_ATMSVC
+--     Just AF_ATMSVC -> Just #const AF_ATMSVC
+-- #endif
+-- #ifdef AF_IRDA
+--     Just AF_IRDA -> Just #const AF_IRDA
+-- #endif
+-- #ifdef AF_PPPOX
+--     Just AF_PPPOX -> Just #const AF_PPPOX
+-- #endif
+-- #ifdef AF_WANPIPE
+--     Just AF_WANPIPE -> Just #const AF_WANPIPE
+-- #endif
+-- #ifdef AF_BLUETOOTH
+--     Just AF_BLUETOOTH -> Just #const AF_BLUETOOTH
+-- #endif
+-- #ifdef AF_CAN
+--     Just AF_CAN -> Just #const AF_CAN
+-- #endif
+--     _ -> Nothing
+
+-- --------- ----------
+
+-- unpackFamily :: CInt -> Family
+-- unpackFamily f = case f of
+--         (#const AF_UNSPEC) -> AF_UNSPEC
+-- #ifdef AF_UNIX
+--         (#const AF_UNIX) -> AF_UNIX
+-- #endif
+-- #ifdef AF_INET
+--         (#const AF_INET) -> AF_INET
+-- #endif
+-- #ifdef AF_INET6
+--         (#const AF_INET6) -> AF_INET6
+-- #endif
+-- #ifdef AF_IMPLINK
+--         (#const AF_IMPLINK) -> AF_IMPLINK
+-- #endif
+-- #ifdef AF_PUP
+--         (#const AF_PUP) -> AF_PUP
+-- #endif
+-- #ifdef AF_CHAOS
+--         (#const AF_CHAOS) -> AF_CHAOS
+-- #endif
+-- #ifdef AF_NS
+--         (#const AF_NS) -> AF_NS
+-- #endif
+-- #ifdef AF_NBS
+--         (#const AF_NBS) -> AF_NBS
+-- #endif
+-- #ifdef AF_ECMA
+--         (#const AF_ECMA) -> AF_ECMA
+-- #endif
+-- #ifdef AF_DATAKIT
+--         (#const AF_DATAKIT) -> AF_DATAKIT
+-- #endif
+-- #ifdef AF_CCITT
+--         (#const AF_CCITT) -> AF_CCITT
+-- #endif
+-- #ifdef AF_SNA
+--         (#const AF_SNA) -> AF_SNA
+-- #endif
+-- #ifdef AF_DECnet
+--         (#const AF_DECnet) -> AF_DECnet
+-- #endif
+-- #ifdef AF_DLI
+--         (#const AF_DLI) -> AF_DLI
+-- #endif
+-- #ifdef AF_LAT
+--         (#const AF_LAT) -> AF_LAT
+-- #endif
+-- #ifdef AF_HYLINK
+--         (#const AF_HYLINK) -> AF_HYLINK
+-- #endif
+-- #ifdef AF_APPLETALK
+--         (#const AF_APPLETALK) -> AF_APPLETALK
+-- #endif
+-- #ifdef AF_ROUTE
+--         (#const AF_ROUTE) -> AF_ROUTE
+-- #endif
+-- #ifdef AF_NETBIOS
+--         (#const AF_NETBIOS) -> AF_NETBIOS
+-- #endif
+-- #ifdef AF_NIT
+--         (#const AF_NIT) -> AF_NIT
+-- #endif
+-- #ifdef AF_802
+--         (#const AF_802) -> AF_802
+-- #endif
+-- #ifdef AF_ISO
+--         (#const AF_ISO) -> AF_ISO
+-- #endif
+-- #ifdef AF_OSI
+-- # if (!defined(AF_ISO)) || (defined(AF_ISO) && (AF_ISO != AF_OSI))
+--         (#const AF_OSI) -> AF_OSI
+-- # endif
+-- #endif
+-- #ifdef AF_NETMAN
+--         (#const AF_NETMAN) -> AF_NETMAN
+-- #endif
+-- #ifdef AF_X25
+--         (#const AF_X25) -> AF_X25
+-- #endif
+-- #ifdef AF_AX25
+--         (#const AF_AX25) -> AF_AX25
+-- #endif
+-- #ifdef AF_OSINET
+--         (#const AF_OSINET) -> AF_OSINET
+-- #endif
+-- #ifdef AF_GOSSIP
+--         (#const AF_GOSSIP) -> AF_GOSSIP
+-- #endif
+-- #if defined(AF_IPX) && (!defined(AF_NS) || AF_NS != AF_IPX)
+--         (#const AF_IPX) -> AF_IPX
+-- #endif
+-- #ifdef Pseudo_AF_XTP
+--         (#const Pseudo_AF_XTP) -> Pseudo_AF_XTP
+-- #endif
+-- #ifdef AF_CTF
+--         (#const AF_CTF) -> AF_CTF
+-- #endif
+-- #ifdef AF_WAN
+--         (#const AF_WAN) -> AF_WAN
+-- #endif
+-- #ifdef AF_SDL
+--         (#const AF_SDL) -> AF_SDL
+-- #endif
+-- #ifdef AF_NETWARE
+--         (#const AF_NETWARE) -> AF_NETWARE
+-- #endif
+-- #ifdef AF_NDD
+--         (#const AF_NDD) -> AF_NDD
+-- #endif
+-- #ifdef AF_INTF
+--         (#const AF_INTF) -> AF_INTF
+-- #endif
+-- #ifdef AF_COIP
+--         (#const AF_COIP) -> AF_COIP
+-- #endif
+-- #ifdef AF_CNT
+--         (#const AF_CNT) -> AF_CNT
+-- #endif
+-- #ifdef Pseudo_AF_RTIP
+--         (#const Pseudo_AF_RTIP) -> Pseudo_AF_RTIP
+-- #endif
+-- #ifdef Pseudo_AF_PIP
+--         (#const Pseudo_AF_PIP) -> Pseudo_AF_PIP
+-- #endif
+-- #ifdef AF_SIP
+--         (#const AF_SIP) -> AF_SIP
+-- #endif
+-- #ifdef AF_ISDN
+--         (#const AF_ISDN) -> AF_ISDN
+-- #endif
+-- #ifdef Pseudo_AF_KEY
+--         (#const Pseudo_AF_KEY) -> Pseudo_AF_KEY
+-- #endif
+-- #ifdef AF_NATM
+--         (#const AF_NATM) -> AF_NATM
+-- #endif
+-- #ifdef AF_ARP
+--         (#const AF_ARP) -> AF_ARP
+-- #endif
+-- #ifdef Pseudo_AF_HDRCMPLT
+--         (#const Pseudo_AF_HDRCMPLT) -> Pseudo_AF_HDRCMPLT
+-- #endif
+-- #ifdef AF_ENCAP
+--         (#const AF_ENCAP) -> AF_ENCAP
+-- #endif
+-- #ifdef AF_LINK
+--         (#const AF_LINK) -> AF_LINK
+-- #endif
+-- #ifdef AF_RAW
+--         (#const AF_RAW) -> AF_RAW
+-- #endif
+-- #ifdef AF_RIF
+--         (#const AF_RIF) -> AF_RIF
+-- #endif
+-- #ifdef AF_NETROM
+--         (#const AF_NETROM) -> AF_NETROM
+-- #endif
+-- #ifdef AF_BRIDGE
+--         (#const AF_BRIDGE) -> AF_BRIDGE
+-- #endif
+-- #ifdef AF_ATMPVC
+--         (#const AF_ATMPVC) -> AF_ATMPVC
+-- #endif
+-- #ifdef AF_ROSE
+--         (#const AF_ROSE) -> AF_ROSE
+-- #endif
+-- #ifdef AF_NETBEUI
+--         (#const AF_NETBEUI) -> AF_NETBEUI
+-- #endif
+-- #ifdef AF_SECURITY
+--         (#const AF_SECURITY) -> AF_SECURITY
+-- #endif
+-- #ifdef AF_PACKET
+--         (#const AF_PACKET) -> AF_PACKET
+-- #endif
+-- #ifdef AF_ASH
+--         (#const AF_ASH) -> AF_ASH
+-- #endif
+-- #ifdef AF_ECONET
+--         (#const AF_ECONET) -> AF_ECONET
+-- #endif
+-- #ifdef AF_ATMSVC
+--         (#const AF_ATMSVC) -> AF_ATMSVC
+-- #endif
+-- #ifdef AF_IRDA
+--         (#const AF_IRDA) -> AF_IRDA
+-- #endif
+-- #ifdef AF_PPPOX
+--         (#const AF_PPPOX) -> AF_PPPOX
+-- #endif
+-- #ifdef AF_WANPIPE
+--         (#const AF_WANPIPE) -> AF_WANPIPE
+-- #endif
+-- #ifdef AF_BLUETOOTH
+--         (#const AF_BLUETOOTH) -> AF_BLUETOOTH
+-- #endif
+-- #ifdef AF_CAN
+--         (#const AF_CAN) -> AF_CAN
+-- #endif
+--         unknown -> error ("Network.Socket.unpackFamily: unknown address " ++
+--                           "family " ++ show unknown)
+
+-- ------------------------------------------------------------------------
+-- -- Port Numbers
+
+-- -- | Use the @Num@ instance (i.e. use a literal) to create a
+-- -- @PortNumber@ value with the correct network-byte-ordering. You
+-- -- should not use the PortNum constructor. It will be removed in the
+-- -- next release.
+-- --
+-- -- >>> 1 :: PortNumber
+-- -- 1
+-- -- >>> read "1" :: PortNumber
+-- -- 1
+newtype PortNumber = PortNum Word16 deriving (Eq, Ord, Typeable)
+-- newtyped to prevent accidental use of sane-looking
+-- port numbers that haven't actually been converted to
+-- network-byte-order first.
+
+-- {-# DEPRECATED PortNum "Do not use the PortNum constructor. Use the Num instance. PortNum will be removed in the next release." #-}
+
+instance Show PortNumber where
+  showsPrec p pn = showsPrec p (portNumberToInt pn)
+
+instance Read PortNumber where
+  readsPrec n = map (\(x,y) -> (intToPortNumber x, y)) . readsPrec n
+
+intToPortNumber :: Int -> PortNumber
+intToPortNumber v = PortNum (fromIntegral v)
+
+portNumberToInt :: PortNumber -> Int
+portNumberToInt (PortNum po) = fromIntegral po
+
+-- foreign import CALLCONV unsafe "ntohs" ntohs :: Word16 -> Word16
+-- foreign import CALLCONV unsafe "htons" htons :: Word16 -> Word16
+-- foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
+-- foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
+
+instance Enum PortNumber where
+    toEnum   = intToPortNumber
+    fromEnum = portNumberToInt
+
+instance Num PortNumber where
+   fromInteger i = intToPortNumber (fromInteger i)
+    -- for completeness.
+   (+) x y   = intToPortNumber (portNumberToInt x + portNumberToInt y)
+   (-) x y   = intToPortNumber (portNumberToInt x - portNumberToInt y)
+   negate x  = intToPortNumber (-portNumberToInt x)
+   (*) x y   = intToPortNumber (portNumberToInt x * portNumberToInt y)
+   abs n     = intToPortNumber (abs (portNumberToInt n))
+   signum n  = intToPortNumber (signum (portNumberToInt n))
+
+instance Real PortNumber where
+    toRational x = toInteger x % 1
+
+instance Integral PortNumber where
+    quotRem a b = let (c,d) = quotRem (portNumberToInt a) (portNumberToInt b) in
+                  (intToPortNumber c, intToPortNumber d)
+    toInteger a = toInteger (portNumberToInt a)
+
+instance Storable PortNumber where
+   sizeOf    _ = sizeOf    (undefined :: Word16)
+   alignment _ = alignment (undefined :: Word16)
+   poke p (PortNum po) = poke (castPtr p) po
+   peek p = PortNum `liftM` peek (castPtr p)
+
+------------------------------------------------------------------------
+-- Socket addresses
+
+-- The scheme used for addressing sockets is somewhat quirky. The
+-- calls in the BSD socket API that need to know the socket address
+-- all operate in terms of struct sockaddr, a `virtual' type of
+-- socket address.
+
+-- The Internet family of sockets are addressed as struct sockaddr_in,
+-- so when calling functions that operate on struct sockaddr, we have
+-- to type cast the Internet socket address into a struct sockaddr.
+-- Instances of the structure for different families might *not* be
+-- the same size. Same casting is required of other families of
+-- sockets such as Xerox NS. Similarly for Unix domain sockets.
+
+-- To represent these socket addresses in Haskell-land, we do what BSD
+-- didn't do, and use a union/algebraic type for the different
+-- families. Currently only Unix domain sockets and the Internet
+-- families are supported.
+
+-- #if defined(IPV6_SOCKET_SUPPORT)
+type FlowInfo = Word32
+type ScopeID = Word32
+-- #endif
+
+-- | The existence of a constructor does not necessarily imply that
+-- that socket address type is supported on your system: see
+-- 'isSupportedSockAddr'.
+data SockAddr       -- C Names
+  = SockAddrInet
+    PortNumber  -- sin_port  (network byte order)
+    HostAddress -- sin_addr  (ditto)
+  | SockAddrInet6
+        PortNumber      -- sin6_port (network byte order)
+        FlowInfo        -- sin6_flowinfo (ditto)
+        HostAddress6    -- sin6_addr (ditto)
+        ScopeID         -- sin6_scope_id (ditto)
+  | SockAddrUnix
+        String          -- sun_path
+  | SockAddrCan
+        Int32           -- can_ifindex (can be get by Network.BSD.ifNameToIndex "can0")
+        -- TODO: Extend this to include transport protocol information
+  deriving (Eq, Ord, Typeable)
+
+-- -- | Is the socket address type supported on this system?
+-- isSupportedSockAddr :: SockAddr -> Bool
+-- isSupportedSockAddr addr = case addr of
+--   SockAddrInet {} -> True
+-- #if defined(IPV6_SOCKET_SUPPORT)
+--   SockAddrInet6 {} -> True
+-- #endif
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+--   SockAddrUnix{} -> True
+-- #endif
+-- #if defined(CAN_SOCKET_SUPPORT)
+--   SockAddrCan{} -> True
+-- #endif
+-- #if !(defined(IPV6_SOCKET_SUPPORT) \
+--       && defined(DOMAIN_SOCKET_SUPPORT) && defined(CAN_SOCKET_SUPPORT))
+--   _ -> False
+-- #endif
+
+-- #if defined(WITH_WINSOCK)
+-- type CSaFamily = (#type unsigned short)
+-- #elif defined(darwin_HOST_OS)
+-- type CSaFamily = (#type u_char)
+-- #else
+-- type CSaFamily = (#type sa_family_t)
+-- #endif
+
+-- -- | Computes the storage requirements (in bytes) of the given
+-- -- 'SockAddr'.  This function differs from 'Foreign.Storable.sizeOf'
+-- -- in that the value of the argument /is/ used.
+-- sizeOfSockAddr :: SockAddr -> Int
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+-- sizeOfSockAddr (SockAddrUnix path) =
+--     case path of
+--         '\0':_ -> (#const sizeof(sa_family_t)) + length path
+--         _      -> #const sizeof(struct sockaddr_un)
+-- #endif
+-- sizeOfSockAddr (SockAddrInet _ _) = #const sizeof(struct sockaddr_in)
+-- #if defined(IPV6_SOCKET_SUPPORT)
+-- sizeOfSockAddr (SockAddrInet6 _ _ _ _) = #const sizeof(struct sockaddr_in6)
+-- #endif
+-- #if defined(CAN_SOCKET_SUPPORT)
+-- sizeOfSockAddr (SockAddrCan _) = #const sizeof(struct sockaddr_can)
+-- #endif
+
+-- -- | Computes the storage requirements (in bytes) required for a
+-- -- 'SockAddr' with the given 'Family'.
+-- sizeOfSockAddrByFamily :: Family -> Int
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+-- sizeOfSockAddrByFamily AF_UNIX  = #const sizeof(struct sockaddr_un)
+-- #endif
+-- #if defined(IPV6_SOCKET_SUPPORT)
+-- sizeOfSockAddrByFamily AF_INET6 = #const sizeof(struct sockaddr_in6)
+-- #endif
+-- sizeOfSockAddrByFamily AF_INET  = #const sizeof(struct sockaddr_in)
+-- #if defined(CAN_SOCKET_SUPPORT)
+-- sizeOfSockAddrByFamily AF_CAN   = #const sizeof(struct sockaddr_can)
+-- #endif
+-- sizeOfSockAddrByFamily family =
+--     error $ "sizeOfSockAddrByFamily: " ++ show family ++ " not supported."
+
+-- -- | Use a 'SockAddr' with a function requiring a pointer to a
+-- -- 'SockAddr' and the length of that 'SockAddr'.
+-- withSockAddr :: SockAddr -> (Ptr SockAddr -> Int -> IO a) -> IO a
+-- withSockAddr addr f = do
+--     let sz = sizeOfSockAddr addr
+--     allocaBytes sz $ \p -> pokeSockAddr p addr >> f (castPtr p) sz
+
+-- -- | Create a new 'SockAddr' for use with a function requiring a
+-- -- pointer to a 'SockAddr' and the length of that 'SockAddr'.
+-- withNewSockAddr :: Family -> (Ptr SockAddr -> Int -> IO a) -> IO a
+-- withNewSockAddr family f = do
+--     let sz = sizeOfSockAddrByFamily family
+--     allocaBytes sz $ \ptr -> f ptr sz
+
+-- -- We can't write an instance of 'Storable' for 'SockAddr' because
+-- -- @sockaddr@ is a sum type of variable size but
+-- -- 'Foreign.Storable.sizeOf' is required to be constant.
+
+-- -- Note that on Darwin, the sockaddr structure must be zeroed before
+-- -- use.
+
+-- -- | Write the given 'SockAddr' to the given memory location.
+-- pokeSockAddr :: Ptr a -> SockAddr -> IO ()
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+-- pokeSockAddr p (SockAddrUnix path) = do
+-- #if defined(darwin_HOST_OS)
+--     zeroMemory p (#const sizeof(struct sockaddr_un))
+-- #endif
+-- #if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
+--     (#poke struct sockaddr_un, sun_len) p ((#const sizeof(struct sockaddr_un)) :: Word8)
+-- #endif
+--     (#poke struct sockaddr_un, sun_family) p ((#const AF_UNIX) :: CSaFamily)
+--     let pathC = map castCharToCChar path
+--         poker = case path of ('\0':_) -> pokeArray; _ -> pokeArray0 0
+--     poker ((#ptr struct sockaddr_un, sun_path) p) pathC
+-- #endif
+-- pokeSockAddr p (SockAddrInet (PortNum port) addr) = do
+-- #if defined(darwin_HOST_OS)
+--     zeroMemory p (#const sizeof(struct sockaddr_in))
+-- #endif
+-- #if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
+--     (#poke struct sockaddr_in, sin_len) p ((#const sizeof(struct sockaddr_in)) :: Word8)
+-- #endif
+--     (#poke struct sockaddr_in, sin_family) p ((#const AF_INET) :: CSaFamily)
+--     (#poke struct sockaddr_in, sin_port) p port
+--     (#poke struct sockaddr_in, sin_addr) p addr
+-- #if defined(IPV6_SOCKET_SUPPORT)
+-- pokeSockAddr p (SockAddrInet6 (PortNum port) flow addr scope) = do
+-- #if defined(darwin_HOST_OS)
+--     zeroMemory p (#const sizeof(struct sockaddr_in6))
+-- #endif
+-- #if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
+--     (#poke struct sockaddr_in6, sin6_len) p ((#const sizeof(struct sockaddr_in6)) :: Word8)
+-- #endif
+--     (#poke struct sockaddr_in6, sin6_family) p ((#const AF_INET6) :: CSaFamily)
+--     (#poke struct sockaddr_in6, sin6_port) p port
+--     (#poke struct sockaddr_in6, sin6_flowinfo) p flow
+--     (#poke struct sockaddr_in6, sin6_addr) p (In6Addr addr)
+--     (#poke struct sockaddr_in6, sin6_scope_id) p scope
+-- #endif
+-- #if defined(CAN_SOCKET_SUPPORT)
+-- pokeSockAddr p (SockAddrCan ifIndex) = do
+-- #if defined(darwin_HOST_OS)
+--     zeroMemory p (#const sizeof(struct sockaddr_can))
+-- #endif
+--     (#poke struct sockaddr_can, can_ifindex) p ifIndex
+-- #endif
+
+-- -- | Read a 'SockAddr' from the given memory location.
+-- peekSockAddr :: Ptr SockAddr -> IO SockAddr
+-- peekSockAddr p = do
+--   family <- (#peek struct sockaddr, sa_family) p
+--   case family :: CSaFamily of
+-- #if defined(DOMAIN_SOCKET_SUPPORT)
+--     (#const AF_UNIX) -> do
+--         str <- peekCString ((#ptr struct sockaddr_un, sun_path) p)
+--         return (SockAddrUnix str)
+-- #endif
+--     (#const AF_INET) -> do
+--         addr <- (#peek struct sockaddr_in, sin_addr) p
+--         port <- (#peek struct sockaddr_in, sin_port) p
+--         return (SockAddrInet (PortNum port) addr)
+-- #if defined(IPV6_SOCKET_SUPPORT)
+--     (#const AF_INET6) -> do
+--         port <- (#peek struct sockaddr_in6, sin6_port) p
+--         flow <- (#peek struct sockaddr_in6, sin6_flowinfo) p
+--         In6Addr addr <- (#peek struct sockaddr_in6, sin6_addr) p
+--         scope <- (#peek struct sockaddr_in6, sin6_scope_id) p
+--         return (SockAddrInet6 (PortNum port) flow addr scope)
+-- #endif
+-- #if defined(CAN_SOCKET_SUPPORT)
+--     (#const AF_CAN) -> do
+--         ifidx <- (#peek struct sockaddr_can, can_ifindex) p
+--         return (SockAddrCan ifidx)
+-- #endif
+--     _ -> throwIO $ userError $ "peekSockAddr: " ++ show family ++ " not supported on this platform."
+
+------------------------------------------------------------------------
+
+-- | The raw network byte order number is read using host byte order.
+-- Therefore on little-endian architectures the byte order is swapped. For
+-- example @127.0.0.1@ is represented as @0x0100007f@ on little-endian hosts
+-- and as @0x7f000001@ on big-endian hosts.
+--
+-- For direct manipulation prefer 'hostAddressToTuple' and
+-- 'tupleToHostAddress'.
+type HostAddress = Word32
+
+-- -- | Converts 'HostAddress' to representation-independent IPv4 quadruple.
+-- -- For example for @127.0.0.1@ the function will return @(0x7f, 0, 0, 1)@
+-- -- regardless of host endianness.
+-- hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)
+-- hostAddressToTuple ha' =
+--     let ha = htonl ha'
+--         byte i = fromIntegral (ha `shiftR` i) :: Word8
+--     in (byte 24, byte 16, byte 8, byte 0)
+
+-- -- | Converts IPv4 quadruple to 'HostAddress'.
+-- tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress
+-- tupleToHostAddress (b3, b2, b1, b0) =
+--     let x `sl` i = fromIntegral x `shiftL` i :: Word32
+--     in ntohl $ (b3 `sl` 24) .|. (b2 `sl` 16) .|. (b1 `sl` 8) .|. (b0 `sl` 0)
+
+-- #if defined(IPV6_SOCKET_SUPPORT)
+-- | Independent of endianness. For example @::1@ is stored as @(0, 0, 0, 1)@.
+--
+-- For direct manipulation prefer 'hostAddress6ToTuple' and
+-- 'tupleToHostAddress6'.
+type HostAddress6 = (Word32, Word32, Word32, Word32)
+
+-- hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16,
+--                                         Word16, Word16, Word16, Word16)
+-- hostAddress6ToTuple (w3, w2, w1, w0) =
+--     let high, low :: Word32 -> Word16
+--         high w = fromIntegral (w `shiftR` 16)
+--         low w = fromIntegral w
+--     in (high w3, low w3, high w2, low w2, high w1, low w1, high w0, low w0)
+
+-- tupleToHostAddress6 :: (Word16, Word16, Word16, Word16,
+--                         Word16, Word16, Word16, Word16) -> HostAddress6
+-- tupleToHostAddress6 (w7, w6, w5, w4, w3, w2, w1, w0) =
+--     let add :: Word16 -> Word16 -> Word32
+--         high `add` low = (fromIntegral high `shiftL` 16) .|. (fromIntegral low)
+--     in (w7 `add` w6, w5 `add` w4, w3 `add` w2, w1 `add` w0)
+
+-- -- The peek32 and poke32 functions work around the fact that the RFCs
+-- -- don't require 32-bit-wide address fields to be present.  We can
+-- -- only portably rely on an 8-bit field, s6_addr.
+
+-- s6_addr_offset :: Int
+-- s6_addr_offset = (#offset struct in6_addr, s6_addr)
+
+-- peek32 :: Ptr a -> Int -> IO Word32
+-- peek32 p i0 = do
+--     let i' = i0 * 4
+--         peekByte n = peekByteOff p (s6_addr_offset + i' + n) :: IO Word8
+--         a `sl` i = fromIntegral a `shiftL` i
+--     a0 <- peekByte 0
+--     a1 <- peekByte 1
+--     a2 <- peekByte 2
+--     a3 <- peekByte 3
+--     return ((a0 `sl` 24) .|. (a1 `sl` 16) .|. (a2 `sl` 8) .|. (a3 `sl` 0))
+
+-- poke32 :: Ptr a -> Int -> Word32 -> IO ()
+-- poke32 p i0 a = do
+--     let i' = i0 * 4
+--         pokeByte n = pokeByteOff p (s6_addr_offset + i' + n)
+--         x `sr` i = fromIntegral (x `shiftR` i) :: Word8
+--     pokeByte 0 (a `sr` 24)
+--     pokeByte 1 (a `sr` 16)
+--     pokeByte 2 (a `sr`  8)
+--     pokeByte 3 (a `sr`  0)
+
+-- | Private newtype proxy for the Storable instance. To avoid orphan instances.
+-- newtype In6Addr = In6Addr HostAddress6
+
+-- #if __GLASGOW_HASKELL__ < 800
+-- #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
+-- #endif
+
+-- instance Storable In6Addr where
+--     sizeOf _    = #const sizeof(struct in6_addr)
+--     alignment _ = #alignment struct in6_addr
+
+--     peek p = do
+--         a <- peek32 p 0
+--         b <- peek32 p 1
+--         c <- peek32 p 2
+--         d <- peek32 p 3
+--         return $ In6Addr (a, b, c, d)
+
+--     poke p (In6Addr (a, b, c, d)) = do
+--         poke32 p 0 a
+--         poke32 p 1 b
+--         poke32 p 2 c
+--         poke32 p 3 d
+-- #endif
+
+------------------------------------------------------------------------
+-- Helper functions
+
+-- foreign import ccall unsafe "string.h" memset :: Ptr a -> CInt -> CSize -> IO ()
+
+-- | Zero a structure.
+-- zeroMemory :: Ptr a -> CSize -> IO ()
+-- zeroMemory dest nbytes = memset dest 0 (fromIntegral nbytes)
diff --git a/Network/Socket/Types.hsc b/Network/Socket/Types.hsc
deleted file mode 100644
index b42c98d..0000000
--- a/Network/Socket/Types.hsc
+++ /dev/null
@@ -1,1103 +0,0 @@
-{-# LANGUAGE DeriveDataTypeable #-}
-{-# LANGUAGE FlexibleInstances #-}
-{-# LANGUAGE ForeignFunctionInterface #-}
-
-#include "HsNet.h"
-
-module Network.Socket.Types
-    (
-    -- * Socket
-      Socket(..)
-    , sockFd
-    , sockFamily
-    , sockType
-    , sockProtocol
-    , sockStatus
-    , SocketStatus(..)
-
-    -- * Socket types
-    , SocketType(..)
-    , isSupportedSocketType
-    , packSocketType
-    , packSocketType'
-    , packSocketTypeOrThrow
-    , unpackSocketType
-    , unpackSocketType'
-
-    -- * Family
-    , Family(..)
-    , isSupportedFamily
-    , packFamily
-    , unpackFamily
-
-    -- * Socket addresses
-    , SockAddr(..)
-    , isSupportedSockAddr
-    , HostAddress
-    , hostAddressToTuple
-    , tupleToHostAddress
-#if defined(IPV6_SOCKET_SUPPORT)
-    , HostAddress6
-    , hostAddress6ToTuple
-    , tupleToHostAddress6
-    , FlowInfo
-    , ScopeID
-#endif
-    , peekSockAddr
-    , pokeSockAddr
-    , sizeOfSockAddr
-    , sizeOfSockAddrByFamily
-    , withSockAddr
-    , withNewSockAddr
-
-    -- * Unsorted
-    , ProtocolNumber
-    , PortNumber(..)
-
-    -- * Low-level helpers
-    , zeroMemory
-    ) where
-
-import Control.Concurrent.MVar
-import Control.Exception (throwIO)
-import Control.Monad
-import Data.Bits
-import Data.Maybe
-import Data.Ratio
-import Data.Typeable
-import Data.Word
-import Data.Int
-import Foreign.C
-import Foreign.Marshal.Alloc
-import Foreign.Marshal.Array
-import Foreign.Ptr
-import Foreign.Storable
-
--- | Represents a socket.  The fields are, respectively:
---
---   * File descriptor
---   * Socket family
---   * Socket type
---   * Protocol number
---   * Status flag
---
---   If you are calling the 'MkSocket' constructor directly you should ensure
---   you have called 'Network.withSocketsDo'.
-data Socket
-  = MkSocket
-            CInt                 -- File Descriptor
-            Family
-            SocketType
-            ProtocolNumber       -- Protocol Number
-            (MVar SocketStatus)  -- Status Flag
-  deriving Typeable
-
-sockFd :: Socket -> CInt
-sockFd       (MkSocket n _ _ _ _) = n
-
-sockFamily :: Socket -> Family
-sockFamily   (MkSocket _ f _ _ _) = f
-
-sockType :: Socket -> SocketType
-sockType     (MkSocket _ _ t _ _) = t
-
-sockProtocol :: Socket -> ProtocolNumber
-sockProtocol (MkSocket _ _ _ p _) = p
-
-sockStatus :: Socket -> MVar SocketStatus
-sockStatus   (MkSocket _ _ _ _ s) = s
-
-instance Eq Socket where
-  (MkSocket _ _ _ _ m1) == (MkSocket _ _ _ _ m2) = m1 == m2
-
-instance Show Socket where
-  showsPrec _n (MkSocket fd _ _ _ _) =
-        showString "<socket: " . shows fd . showString ">"
-
-type ProtocolNumber = CInt
-
--- | The status of the socket as /determined by this library/, not
--- necessarily reflecting the state of the connection itself.
---
--- For example, the 'Closed' status is applied when the 'close'
--- function is called.
-data SocketStatus
-  -- Returned Status    Function called
-  = NotConnected        -- ^ Newly created, unconnected socket
-  | Bound               -- ^ Bound, via 'bind'
-  | Listening           -- ^ Listening, via 'listen'
-  | Connected           -- ^ Connected or accepted, via 'connect' or 'accept'
-  | ConvertedToHandle   -- ^ Is now a 'Handle' (via 'socketToHandle'), don't touch
-  | Closed              -- ^ Closed was closed by 'close'
-    deriving (Eq, Show, Typeable)
-
------------------------------------------------------------------------------
--- Socket types
-
--- There are a few possible ways to do this.  The first is convert the
--- structs used in the C library into an equivalent Haskell type. An
--- other possible implementation is to keep all the internals in the C
--- code and use an Int## and a status flag. The second method is used
--- here since a lot of the C structures are not required to be
--- manipulated.
-
--- Originally the status was non-mutable so we had to return a new
--- socket each time we changed the status.  This version now uses
--- mutable variables to avoid the need to do this.  The result is a
--- cleaner interface and better security since the application
--- programmer now can't circumvent the status information to perform
--- invalid operations on sockets.
-
--- | Socket Types.
---
--- The existence of a constructor does not necessarily imply that that
--- socket type is supported on your system: see 'isSupportedSocketType'.
-data SocketType
-        = NoSocketType -- ^ 0, used in getAddrInfo hints, for example
-        | Stream -- ^ SOCK_STREAM
-        | Datagram -- ^ SOCK_DGRAM
-        | Raw -- ^ SOCK_RAW
-        | RDM -- ^ SOCK_RDM
-        | SeqPacket -- ^ SOCK_SEQPACKET
-        deriving (Eq, Ord, Read, Show, Typeable)
-
--- | Does the SOCK_ constant corresponding to the given SocketType exist on
--- this system?
-isSupportedSocketType :: SocketType -> Bool
-isSupportedSocketType = isJust . packSocketType'
-
--- | Find the SOCK_ constant corresponding to the SocketType value.
-packSocketType' :: SocketType -> Maybe CInt
-packSocketType' stype = case Just stype of
-    -- the Just above is to disable GHC's overlapping pattern
-    -- detection: see comments for packSocketOption
-    Just NoSocketType -> Just 0
-#ifdef SOCK_STREAM
-    Just Stream -> Just #const SOCK_STREAM
-#endif
-#ifdef SOCK_DGRAM
-    Just Datagram -> Just #const SOCK_DGRAM
-#endif
-#ifdef SOCK_RAW
-    Just Raw -> Just #const SOCK_RAW
-#endif
-#ifdef SOCK_RDM
-    Just RDM -> Just #const SOCK_RDM
-#endif
-#ifdef SOCK_SEQPACKET
-    Just SeqPacket -> Just #const SOCK_SEQPACKET
-#endif
-    _ -> Nothing
-
-packSocketType :: SocketType -> CInt
-packSocketType stype = fromMaybe (error errMsg) (packSocketType' stype)
-  where
-    errMsg = concat ["Network.Socket.packSocketType: ",
-                     "socket type ", show stype, " unsupported on this system"]
-
--- | Try packSocketType' on the SocketType, if it fails throw an error with
--- message starting "Network.Socket." ++ the String parameter
-packSocketTypeOrThrow :: String -> SocketType -> IO CInt
-packSocketTypeOrThrow caller stype = maybe err return (packSocketType' stype)
- where
-  err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
-    "socket type ", show stype, " unsupported on this system"]
-
-
-unpackSocketType:: CInt -> Maybe SocketType
-unpackSocketType t = case t of
-        0 -> Just NoSocketType
-#ifdef SOCK_STREAM
-        (#const SOCK_STREAM) -> Just Stream
-#endif
-#ifdef SOCK_DGRAM
-        (#const SOCK_DGRAM) -> Just Datagram
-#endif
-#ifdef SOCK_RAW
-        (#const SOCK_RAW) -> Just Raw
-#endif
-#ifdef SOCK_RDM
-        (#const SOCK_RDM) -> Just RDM
-#endif
-#ifdef SOCK_SEQPACKET
-        (#const SOCK_SEQPACKET) -> Just SeqPacket
-#endif
-        _ -> Nothing
-
--- | Try unpackSocketType on the CInt, if it fails throw an error with
--- message starting "Network.Socket." ++ the String parameter
-unpackSocketType' :: String -> CInt -> IO SocketType
-unpackSocketType' caller ty = maybe err return (unpackSocketType ty)
- where
-  err = ioError . userError . concat $ ["Network.Socket.", caller, ": ",
-    "socket type ", show ty, " unsupported on this system"]
-
-------------------------------------------------------------------------
--- Protocol Families.
-
--- | Address families.
---
--- A constructor being present here does not mean it is supported by the
--- operating system: see 'isSupportedFamily'.
-data Family
-    = AF_UNSPEC           -- unspecified
-    | AF_UNIX             -- local to host (pipes, portals
-    | AF_INET             -- internetwork: UDP, TCP, etc
-    | AF_INET6            -- Internet Protocol version 6
-    | AF_IMPLINK          -- arpanet imp addresses
-    | AF_PUP              -- pup protocols: e.g. BSP
-    | AF_CHAOS            -- mit CHAOS protocols
-    | AF_NS               -- XEROX NS protocols
-    | AF_NBS              -- nbs protocols
-    | AF_ECMA             -- european computer manufacturers
-    | AF_DATAKIT          -- datakit protocols
-    | AF_CCITT            -- CCITT protocols, X.25 etc
-    | AF_SNA              -- IBM SNA
-    | AF_DECnet           -- DECnet
-    | AF_DLI              -- Direct data link interface
-    | AF_LAT              -- LAT
-    | AF_HYLINK           -- NSC Hyperchannel
-    | AF_APPLETALK        -- Apple Talk
-    | AF_ROUTE            -- Internal Routing Protocol
-    | AF_NETBIOS          -- NetBios-style addresses
-    | AF_NIT              -- Network Interface Tap
-    | AF_802              -- IEEE 802.2, also ISO 8802
-    | AF_ISO              -- ISO protocols
-    | AF_OSI              -- umbrella of all families used by OSI
-    | AF_NETMAN           -- DNA Network Management
-    | AF_X25              -- CCITT X.25
-    | AF_AX25
-    | AF_OSINET           -- AFI
-    | AF_GOSSIP           -- US Government OSI
-    | AF_IPX              -- Novell Internet Protocol
-    | Pseudo_AF_XTP       -- eXpress Transfer Protocol (no AF)
-    | AF_CTF              -- Common Trace Facility
-    | AF_WAN              -- Wide Area Network protocols
-    | AF_SDL              -- SGI Data Link for DLPI
-    | AF_NETWARE
-    | AF_NDD
-    | AF_INTF             -- Debugging use only
-    | AF_COIP             -- connection-oriented IP, aka ST II
-    | AF_CNT              -- Computer Network Technology
-    | Pseudo_AF_RTIP      -- Help Identify RTIP packets
-    | Pseudo_AF_PIP       -- Help Identify PIP packets
-    | AF_SIP              -- Simple Internet Protocol
-    | AF_ISDN             -- Integrated Services Digital Network
-    | Pseudo_AF_KEY       -- Internal key-management function
-    | AF_NATM             -- native ATM access
-    | AF_ARP              -- (rev.) addr. res. prot. (RFC 826)
-    | Pseudo_AF_HDRCMPLT  -- Used by BPF to not rewrite hdrs in iface output
-    | AF_ENCAP
-    | AF_LINK             -- Link layer interface
-    | AF_RAW              -- Link layer interface
-    | AF_RIF              -- raw interface
-    | AF_NETROM           -- Amateur radio NetROM
-    | AF_BRIDGE           -- multiprotocol bridge
-    | AF_ATMPVC           -- ATM PVCs
-    | AF_ROSE             -- Amateur Radio X.25 PLP
-    | AF_NETBEUI          -- 802.2LLC
-    | AF_SECURITY         -- Security callback pseudo AF
-    | AF_PACKET           -- Packet family
-    | AF_ASH              -- Ash
-    | AF_ECONET           -- Acorn Econet
-    | AF_ATMSVC           -- ATM SVCs
-    | AF_IRDA             -- IRDA sockets
-    | AF_PPPOX            -- PPPoX sockets
-    | AF_WANPIPE          -- Wanpipe API sockets
-    | AF_BLUETOOTH        -- bluetooth sockets
-    | AF_CAN              -- Controller Area Network
-      deriving (Eq, Ord, Read, Show)
-
-packFamily :: Family -> CInt
-packFamily f = case packFamily' f of
-    Just fam -> fam
-    Nothing -> error $
-               "Network.Socket.packFamily: unsupported address family: " ++
-               show f
-
--- | Does the AF_ constant corresponding to the given family exist on this
--- system?
-isSupportedFamily :: Family -> Bool
-isSupportedFamily = isJust . packFamily'
-
-packFamily' :: Family -> Maybe CInt
-packFamily' f = case Just f of
-    -- the Just above is to disable GHC's overlapping pattern
-    -- detection: see comments for packSocketOption
-    Just AF_UNSPEC -> Just #const AF_UNSPEC
-#ifdef AF_UNIX
-    Just AF_UNIX -> Just #const AF_UNIX
-#endif
-#ifdef AF_INET
-    Just AF_INET -> Just #const AF_INET
-#endif
-#ifdef AF_INET6
-    Just AF_INET6 -> Just #const AF_INET6
-#endif
-#ifdef AF_IMPLINK
-    Just AF_IMPLINK -> Just #const AF_IMPLINK
-#endif
-#ifdef AF_PUP
-    Just AF_PUP -> Just #const AF_PUP
-#endif
-#ifdef AF_CHAOS
-    Just AF_CHAOS -> Just #const AF_CHAOS
-#endif
-#ifdef AF_NS
-    Just AF_NS -> Just #const AF_NS
-#endif
-#ifdef AF_NBS
-    Just AF_NBS -> Just #const AF_NBS
-#endif
-#ifdef AF_ECMA
-    Just AF_ECMA -> Just #const AF_ECMA
-#endif
-#ifdef AF_DATAKIT
-    Just AF_DATAKIT -> Just #const AF_DATAKIT
-#endif
-#ifdef AF_CCITT
-    Just AF_CCITT -> Just #const AF_CCITT
-#endif
-#ifdef AF_SNA
-    Just AF_SNA -> Just #const AF_SNA
-#endif
-#ifdef AF_DECnet
-    Just AF_DECnet -> Just #const AF_DECnet
-#endif
-#ifdef AF_DLI
-    Just AF_DLI -> Just #const AF_DLI
-#endif
-#ifdef AF_LAT
-    Just AF_LAT -> Just #const AF_LAT
-#endif
-#ifdef AF_HYLINK
-    Just AF_HYLINK -> Just #const AF_HYLINK
-#endif
-#ifdef AF_APPLETALK
-    Just AF_APPLETALK -> Just #const AF_APPLETALK
-#endif
-#ifdef AF_ROUTE
-    Just AF_ROUTE -> Just #const AF_ROUTE
-#endif
-#ifdef AF_NETBIOS
-    Just AF_NETBIOS -> Just #const AF_NETBIOS
-#endif
-#ifdef AF_NIT
-    Just AF_NIT -> Just #const AF_NIT
-#endif
-#ifdef AF_802
-    Just AF_802 -> Just #const AF_802
-#endif
-#ifdef AF_ISO
-    Just AF_ISO -> Just #const AF_ISO
-#endif
-#ifdef AF_OSI
-    Just AF_OSI -> Just #const AF_OSI
-#endif
-#ifdef AF_NETMAN
-    Just AF_NETMAN -> Just #const AF_NETMAN
-#endif
-#ifdef AF_X25
-    Just AF_X25 -> Just #const AF_X25
-#endif
-#ifdef AF_AX25
-    Just AF_AX25 -> Just #const AF_AX25
-#endif
-#ifdef AF_OSINET
-    Just AF_OSINET -> Just #const AF_OSINET
-#endif
-#ifdef AF_GOSSIP
-    Just AF_GOSSIP -> Just #const AF_GOSSIP
-#endif
-#ifdef AF_IPX
-    Just AF_IPX -> Just #const AF_IPX
-#endif
-#ifdef Pseudo_AF_XTP
-    Just Pseudo_AF_XTP -> Just #const Pseudo_AF_XTP
-#endif
-#ifdef AF_CTF
-    Just AF_CTF -> Just #const AF_CTF
-#endif
-#ifdef AF_WAN
-    Just AF_WAN -> Just #const AF_WAN
-#endif
-#ifdef AF_SDL
-    Just AF_SDL -> Just #const AF_SDL
-#endif
-#ifdef AF_NETWARE
-    Just AF_NETWARE -> Just #const AF_NETWARE
-#endif
-#ifdef AF_NDD
-    Just AF_NDD -> Just #const AF_NDD
-#endif
-#ifdef AF_INTF
-    Just AF_INTF -> Just #const AF_INTF
-#endif
-#ifdef AF_COIP
-    Just AF_COIP -> Just #const AF_COIP
-#endif
-#ifdef AF_CNT
-    Just AF_CNT -> Just #const AF_CNT
-#endif
-#ifdef Pseudo_AF_RTIP
-    Just Pseudo_AF_RTIP -> Just #const Pseudo_AF_RTIP
-#endif
-#ifdef Pseudo_AF_PIP
-    Just Pseudo_AF_PIP -> Just #const Pseudo_AF_PIP
-#endif
-#ifdef AF_SIP
-    Just AF_SIP -> Just #const AF_SIP
-#endif
-#ifdef AF_ISDN
-    Just AF_ISDN -> Just #const AF_ISDN
-#endif
-#ifdef Pseudo_AF_KEY
-    Just Pseudo_AF_KEY -> Just #const Pseudo_AF_KEY
-#endif
-#ifdef AF_NATM
-    Just AF_NATM -> Just #const AF_NATM
-#endif
-#ifdef AF_ARP
-    Just AF_ARP -> Just #const AF_ARP
-#endif
-#ifdef Pseudo_AF_HDRCMPLT
-    Just Pseudo_AF_HDRCMPLT -> Just #const Pseudo_AF_HDRCMPLT
-#endif
-#ifdef AF_ENCAP
-    Just AF_ENCAP -> Just #const AF_ENCAP
-#endif
-#ifdef AF_LINK
-    Just AF_LINK -> Just #const AF_LINK
-#endif
-#ifdef AF_RAW
-    Just AF_RAW -> Just #const AF_RAW
-#endif
-#ifdef AF_RIF
-    Just AF_RIF -> Just #const AF_RIF
-#endif
-#ifdef AF_NETROM
-    Just AF_NETROM -> Just #const AF_NETROM
-#endif
-#ifdef AF_BRIDGE
-    Just AF_BRIDGE -> Just #const AF_BRIDGE
-#endif
-#ifdef AF_ATMPVC
-    Just AF_ATMPVC -> Just #const AF_ATMPVC
-#endif
-#ifdef AF_ROSE
-    Just AF_ROSE -> Just #const AF_ROSE
-#endif
-#ifdef AF_NETBEUI
-    Just AF_NETBEUI -> Just #const AF_NETBEUI
-#endif
-#ifdef AF_SECURITY
-    Just AF_SECURITY -> Just #const AF_SECURITY
-#endif
-#ifdef AF_PACKET
-    Just AF_PACKET -> Just #const AF_PACKET
-#endif
-#ifdef AF_ASH
-    Just AF_ASH -> Just #const AF_ASH
-#endif
-#ifdef AF_ECONET
-    Just AF_ECONET -> Just #const AF_ECONET
-#endif
-#ifdef AF_ATMSVC
-    Just AF_ATMSVC -> Just #const AF_ATMSVC
-#endif
-#ifdef AF_IRDA
-    Just AF_IRDA -> Just #const AF_IRDA
-#endif
-#ifdef AF_PPPOX
-    Just AF_PPPOX -> Just #const AF_PPPOX
-#endif
-#ifdef AF_WANPIPE
-    Just AF_WANPIPE -> Just #const AF_WANPIPE
-#endif
-#ifdef AF_BLUETOOTH
-    Just AF_BLUETOOTH -> Just #const AF_BLUETOOTH
-#endif
-#ifdef AF_CAN
-    Just AF_CAN -> Just #const AF_CAN
-#endif
-    _ -> Nothing
-
---------- ----------
-
-unpackFamily :: CInt -> Family
-unpackFamily f = case f of
-        (#const AF_UNSPEC) -> AF_UNSPEC
-#ifdef AF_UNIX
-        (#const AF_UNIX) -> AF_UNIX
-#endif
-#ifdef AF_INET
-        (#const AF_INET) -> AF_INET
-#endif
-#ifdef AF_INET6
-        (#const AF_INET6) -> AF_INET6
-#endif
-#ifdef AF_IMPLINK
-        (#const AF_IMPLINK) -> AF_IMPLINK
-#endif
-#ifdef AF_PUP
-        (#const AF_PUP) -> AF_PUP
-#endif
-#ifdef AF_CHAOS
-        (#const AF_CHAOS) -> AF_CHAOS
-#endif
-#ifdef AF_NS
-        (#const AF_NS) -> AF_NS
-#endif
-#ifdef AF_NBS
-        (#const AF_NBS) -> AF_NBS
-#endif
-#ifdef AF_ECMA
-        (#const AF_ECMA) -> AF_ECMA
-#endif
-#ifdef AF_DATAKIT
-        (#const AF_DATAKIT) -> AF_DATAKIT
-#endif
-#ifdef AF_CCITT
-        (#const AF_CCITT) -> AF_CCITT
-#endif
-#ifdef AF_SNA
-        (#const AF_SNA) -> AF_SNA
-#endif
-#ifdef AF_DECnet
-        (#const AF_DECnet) -> AF_DECnet
-#endif
-#ifdef AF_DLI
-        (#const AF_DLI) -> AF_DLI
-#endif
-#ifdef AF_LAT
-        (#const AF_LAT) -> AF_LAT
-#endif
-#ifdef AF_HYLINK
-        (#const AF_HYLINK) -> AF_HYLINK
-#endif
-#ifdef AF_APPLETALK
-        (#const AF_APPLETALK) -> AF_APPLETALK
-#endif
-#ifdef AF_ROUTE
-        (#const AF_ROUTE) -> AF_ROUTE
-#endif
-#ifdef AF_NETBIOS
-        (#const AF_NETBIOS) -> AF_NETBIOS
-#endif
-#ifdef AF_NIT
-        (#const AF_NIT) -> AF_NIT
-#endif
-#ifdef AF_802
-        (#const AF_802) -> AF_802
-#endif
-#ifdef AF_ISO
-        (#const AF_ISO) -> AF_ISO
-#endif
-#ifdef AF_OSI
-# if (!defined(AF_ISO)) || (defined(AF_ISO) && (AF_ISO != AF_OSI))
-        (#const AF_OSI) -> AF_OSI
-# endif
-#endif
-#ifdef AF_NETMAN
-        (#const AF_NETMAN) -> AF_NETMAN
-#endif
-#ifdef AF_X25
-        (#const AF_X25) -> AF_X25
-#endif
-#ifdef AF_AX25
-        (#const AF_AX25) -> AF_AX25
-#endif
-#ifdef AF_OSINET
-        (#const AF_OSINET) -> AF_OSINET
-#endif
-#ifdef AF_GOSSIP
-        (#const AF_GOSSIP) -> AF_GOSSIP
-#endif
-#if defined(AF_IPX) && (!defined(AF_NS) || AF_NS != AF_IPX)
-        (#const AF_IPX) -> AF_IPX
-#endif
-#ifdef Pseudo_AF_XTP
-        (#const Pseudo_AF_XTP) -> Pseudo_AF_XTP
-#endif
-#ifdef AF_CTF
-        (#const AF_CTF) -> AF_CTF
-#endif
-#ifdef AF_WAN
-        (#const AF_WAN) -> AF_WAN
-#endif
-#ifdef AF_SDL
-        (#const AF_SDL) -> AF_SDL
-#endif
-#ifdef AF_NETWARE
-        (#const AF_NETWARE) -> AF_NETWARE
-#endif
-#ifdef AF_NDD
-        (#const AF_NDD) -> AF_NDD
-#endif
-#ifdef AF_INTF
-        (#const AF_INTF) -> AF_INTF
-#endif
-#ifdef AF_COIP
-        (#const AF_COIP) -> AF_COIP
-#endif
-#ifdef AF_CNT
-        (#const AF_CNT) -> AF_CNT
-#endif
-#ifdef Pseudo_AF_RTIP
-        (#const Pseudo_AF_RTIP) -> Pseudo_AF_RTIP
-#endif
-#ifdef Pseudo_AF_PIP
-        (#const Pseudo_AF_PIP) -> Pseudo_AF_PIP
-#endif
-#ifdef AF_SIP
-        (#const AF_SIP) -> AF_SIP
-#endif
-#ifdef AF_ISDN
-        (#const AF_ISDN) -> AF_ISDN
-#endif
-#ifdef Pseudo_AF_KEY
-        (#const Pseudo_AF_KEY) -> Pseudo_AF_KEY
-#endif
-#ifdef AF_NATM
-        (#const AF_NATM) -> AF_NATM
-#endif
-#ifdef AF_ARP
-        (#const AF_ARP) -> AF_ARP
-#endif
-#ifdef Pseudo_AF_HDRCMPLT
-        (#const Pseudo_AF_HDRCMPLT) -> Pseudo_AF_HDRCMPLT
-#endif
-#ifdef AF_ENCAP
-        (#const AF_ENCAP) -> AF_ENCAP
-#endif
-#ifdef AF_LINK
-        (#const AF_LINK) -> AF_LINK
-#endif
-#ifdef AF_RAW
-        (#const AF_RAW) -> AF_RAW
-#endif
-#ifdef AF_RIF
-        (#const AF_RIF) -> AF_RIF
-#endif
-#ifdef AF_NETROM
-        (#const AF_NETROM) -> AF_NETROM
-#endif
-#ifdef AF_BRIDGE
-        (#const AF_BRIDGE) -> AF_BRIDGE
-#endif
-#ifdef AF_ATMPVC
-        (#const AF_ATMPVC) -> AF_ATMPVC
-#endif
-#ifdef AF_ROSE
-        (#const AF_ROSE) -> AF_ROSE
-#endif
-#ifdef AF_NETBEUI
-        (#const AF_NETBEUI) -> AF_NETBEUI
-#endif
-#ifdef AF_SECURITY
-        (#const AF_SECURITY) -> AF_SECURITY
-#endif
-#ifdef AF_PACKET
-        (#const AF_PACKET) -> AF_PACKET
-#endif
-#ifdef AF_ASH
-        (#const AF_ASH) -> AF_ASH
-#endif
-#ifdef AF_ECONET
-        (#const AF_ECONET) -> AF_ECONET
-#endif
-#ifdef AF_ATMSVC
-        (#const AF_ATMSVC) -> AF_ATMSVC
-#endif
-#ifdef AF_IRDA
-        (#const AF_IRDA) -> AF_IRDA
-#endif
-#ifdef AF_PPPOX
-        (#const AF_PPPOX) -> AF_PPPOX
-#endif
-#ifdef AF_WANPIPE
-        (#const AF_WANPIPE) -> AF_WANPIPE
-#endif
-#ifdef AF_BLUETOOTH
-        (#const AF_BLUETOOTH) -> AF_BLUETOOTH
-#endif
-#ifdef AF_CAN
-        (#const AF_CAN) -> AF_CAN
-#endif
-        unknown -> error ("Network.Socket.unpackFamily: unknown address " ++
-                          "family " ++ show unknown)
-
-------------------------------------------------------------------------
--- Port Numbers
-
--- | Use the @Num@ instance (i.e. use a literal) to create a
--- @PortNumber@ value with the correct network-byte-ordering. You
--- should not use the PortNum constructor. It will be removed in the
--- next release.
---
--- >>> 1 :: PortNumber
--- 1
--- >>> read "1" :: PortNumber
--- 1
-newtype PortNumber = PortNum Word16 deriving (Eq, Ord, Typeable)
--- newtyped to prevent accidental use of sane-looking
--- port numbers that haven't actually been converted to
--- network-byte-order first.
-
-{-# DEPRECATED PortNum "Do not use the PortNum constructor. Use the Num instance. PortNum will be removed in the next release." #-}
-
-instance Show PortNumber where
-  showsPrec p pn = showsPrec p (portNumberToInt pn)
-
-instance Read PortNumber where
-  readsPrec n = map (\(x,y) -> (intToPortNumber x, y)) . readsPrec n
-
-intToPortNumber :: Int -> PortNumber
-intToPortNumber v = PortNum (htons (fromIntegral v))
-
-portNumberToInt :: PortNumber -> Int
-portNumberToInt (PortNum po) = fromIntegral (ntohs po)
-
-foreign import CALLCONV unsafe "ntohs" ntohs :: Word16 -> Word16
-foreign import CALLCONV unsafe "htons" htons :: Word16 -> Word16
-foreign import CALLCONV unsafe "ntohl" ntohl :: Word32 -> Word32
-foreign import CALLCONV unsafe "htonl" htonl :: Word32 -> Word32
-
-instance Enum PortNumber where
-    toEnum   = intToPortNumber
-    fromEnum = portNumberToInt
-
-instance Num PortNumber where
-   fromInteger i = intToPortNumber (fromInteger i)
-    -- for completeness.
-   (+) x y   = intToPortNumber (portNumberToInt x + portNumberToInt y)
-   (-) x y   = intToPortNumber (portNumberToInt x - portNumberToInt y)
-   negate x  = intToPortNumber (-portNumberToInt x)
-   (*) x y   = intToPortNumber (portNumberToInt x * portNumberToInt y)
-   abs n     = intToPortNumber (abs (portNumberToInt n))
-   signum n  = intToPortNumber (signum (portNumberToInt n))
-
-instance Real PortNumber where
-    toRational x = toInteger x % 1
-
-instance Integral PortNumber where
-    quotRem a b = let (c,d) = quotRem (portNumberToInt a) (portNumberToInt b) in
-                  (intToPortNumber c, intToPortNumber d)
-    toInteger a = toInteger (portNumberToInt a)
-
-instance Storable PortNumber where
-   sizeOf    _ = sizeOf    (undefined :: Word16)
-   alignment _ = alignment (undefined :: Word16)
-   poke p (PortNum po) = poke (castPtr p) po
-   peek p = PortNum `liftM` peek (castPtr p)
-
-------------------------------------------------------------------------
--- Socket addresses
-
--- The scheme used for addressing sockets is somewhat quirky. The
--- calls in the BSD socket API that need to know the socket address
--- all operate in terms of struct sockaddr, a `virtual' type of
--- socket address.
-
--- The Internet family of sockets are addressed as struct sockaddr_in,
--- so when calling functions that operate on struct sockaddr, we have
--- to type cast the Internet socket address into a struct sockaddr.
--- Instances of the structure for different families might *not* be
--- the same size. Same casting is required of other families of
--- sockets such as Xerox NS. Similarly for Unix domain sockets.
-
--- To represent these socket addresses in Haskell-land, we do what BSD
--- didn't do, and use a union/algebraic type for the different
--- families. Currently only Unix domain sockets and the Internet
--- families are supported.
-
-#if defined(IPV6_SOCKET_SUPPORT)
-type FlowInfo = Word32
-type ScopeID = Word32
-#endif
-
--- | The existence of a constructor does not necessarily imply that
--- that socket address type is supported on your system: see
--- 'isSupportedSockAddr'.
-data SockAddr       -- C Names
-  = SockAddrInet
-    PortNumber  -- sin_port  (network byte order)
-    HostAddress -- sin_addr  (ditto)
-  | SockAddrInet6
-        PortNumber      -- sin6_port (network byte order)
-        FlowInfo        -- sin6_flowinfo (ditto)
-        HostAddress6    -- sin6_addr (ditto)
-        ScopeID         -- sin6_scope_id (ditto)
-  | SockAddrUnix
-        String          -- sun_path
-  | SockAddrCan
-        Int32           -- can_ifindex (can be get by Network.BSD.ifNameToIndex "can0")
-        -- TODO: Extend this to include transport protocol information
-  deriving (Eq, Ord, Typeable)
-
--- | Is the socket address type supported on this system?
-isSupportedSockAddr :: SockAddr -> Bool
-isSupportedSockAddr addr = case addr of
-  SockAddrInet {} -> True
-#if defined(IPV6_SOCKET_SUPPORT)
-  SockAddrInet6 {} -> True
-#endif
-#if defined(DOMAIN_SOCKET_SUPPORT)
-  SockAddrUnix{} -> True
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-  SockAddrCan{} -> True
-#endif
-#if !(defined(IPV6_SOCKET_SUPPORT) \
-      && defined(DOMAIN_SOCKET_SUPPORT) && defined(CAN_SOCKET_SUPPORT))
-  _ -> False
-#endif
-
-#if defined(WITH_WINSOCK)
-type CSaFamily = (#type unsigned short)
-#elif defined(darwin_HOST_OS)
-type CSaFamily = (#type u_char)
-#else
-type CSaFamily = (#type sa_family_t)
-#endif
-
--- | Computes the storage requirements (in bytes) of the given
--- 'SockAddr'.  This function differs from 'Foreign.Storable.sizeOf'
--- in that the value of the argument /is/ used.
-sizeOfSockAddr :: SockAddr -> Int
-#if defined(DOMAIN_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrUnix path) =
-    case path of
-        '\0':_ -> (#const sizeof(sa_family_t)) + length path
-        _      -> #const sizeof(struct sockaddr_un)
-#endif
-sizeOfSockAddr (SockAddrInet _ _) = #const sizeof(struct sockaddr_in)
-#if defined(IPV6_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrInet6 _ _ _ _) = #const sizeof(struct sockaddr_in6)
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-sizeOfSockAddr (SockAddrCan _) = #const sizeof(struct sockaddr_can)
-#endif
-
--- | Computes the storage requirements (in bytes) required for a
--- 'SockAddr' with the given 'Family'.
-sizeOfSockAddrByFamily :: Family -> Int
-#if defined(DOMAIN_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_UNIX  = #const sizeof(struct sockaddr_un)
-#endif
-#if defined(IPV6_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_INET6 = #const sizeof(struct sockaddr_in6)
-#endif
-sizeOfSockAddrByFamily AF_INET  = #const sizeof(struct sockaddr_in)
-#if defined(CAN_SOCKET_SUPPORT)
-sizeOfSockAddrByFamily AF_CAN   = #const sizeof(struct sockaddr_can)
-#endif
-sizeOfSockAddrByFamily family =
-    error $ "sizeOfSockAddrByFamily: " ++ show family ++ " not supported."
-
--- | Use a 'SockAddr' with a function requiring a pointer to a
--- 'SockAddr' and the length of that 'SockAddr'.
-withSockAddr :: SockAddr -> (Ptr SockAddr -> Int -> IO a) -> IO a
-withSockAddr addr f = do
-    let sz = sizeOfSockAddr addr
-    allocaBytes sz $ \p -> pokeSockAddr p addr >> f (castPtr p) sz
-
--- | Create a new 'SockAddr' for use with a function requiring a
--- pointer to a 'SockAddr' and the length of that 'SockAddr'.
-withNewSockAddr :: Family -> (Ptr SockAddr -> Int -> IO a) -> IO a
-withNewSockAddr family f = do
-    let sz = sizeOfSockAddrByFamily family
-    allocaBytes sz $ \ptr -> f ptr sz
-
--- We can't write an instance of 'Storable' for 'SockAddr' because
--- @sockaddr@ is a sum type of variable size but
--- 'Foreign.Storable.sizeOf' is required to be constant.
-
--- Note that on Darwin, the sockaddr structure must be zeroed before
--- use.
-
--- | Write the given 'SockAddr' to the given memory location.
-pokeSockAddr :: Ptr a -> SockAddr -> IO ()
-#if defined(DOMAIN_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrUnix path) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_un))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_un, sun_len) p ((#const sizeof(struct sockaddr_un)) :: Word8)
-#endif
-    (#poke struct sockaddr_un, sun_family) p ((#const AF_UNIX) :: CSaFamily)
-    let pathC = map castCharToCChar path
-        poker = case path of ('\0':_) -> pokeArray; _ -> pokeArray0 0
-    poker ((#ptr struct sockaddr_un, sun_path) p) pathC
-#endif
-pokeSockAddr p (SockAddrInet (PortNum port) addr) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_in))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_in, sin_len) p ((#const sizeof(struct sockaddr_in)) :: Word8)
-#endif
-    (#poke struct sockaddr_in, sin_family) p ((#const AF_INET) :: CSaFamily)
-    (#poke struct sockaddr_in, sin_port) p port
-    (#poke struct sockaddr_in, sin_addr) p addr
-#if defined(IPV6_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrInet6 (PortNum port) flow addr scope) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_in6))
-#endif
-#if defined(HAVE_STRUCT_SOCKADDR_SA_LEN)
-    (#poke struct sockaddr_in6, sin6_len) p ((#const sizeof(struct sockaddr_in6)) :: Word8)
-#endif
-    (#poke struct sockaddr_in6, sin6_family) p ((#const AF_INET6) :: CSaFamily)
-    (#poke struct sockaddr_in6, sin6_port) p port
-    (#poke struct sockaddr_in6, sin6_flowinfo) p flow
-    (#poke struct sockaddr_in6, sin6_addr) p (In6Addr addr)
-    (#poke struct sockaddr_in6, sin6_scope_id) p scope
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-pokeSockAddr p (SockAddrCan ifIndex) = do
-#if defined(darwin_HOST_OS)
-    zeroMemory p (#const sizeof(struct sockaddr_can))
-#endif
-    (#poke struct sockaddr_can, can_ifindex) p ifIndex
-#endif
-
--- | Read a 'SockAddr' from the given memory location.
-peekSockAddr :: Ptr SockAddr -> IO SockAddr
-peekSockAddr p = do
-  family <- (#peek struct sockaddr, sa_family) p
-  case family :: CSaFamily of
-#if defined(DOMAIN_SOCKET_SUPPORT)
-    (#const AF_UNIX) -> do
-        str <- peekCString ((#ptr struct sockaddr_un, sun_path) p)
-        return (SockAddrUnix str)
-#endif
-    (#const AF_INET) -> do
-        addr <- (#peek struct sockaddr_in, sin_addr) p
-        port <- (#peek struct sockaddr_in, sin_port) p
-        return (SockAddrInet (PortNum port) addr)
-#if defined(IPV6_SOCKET_SUPPORT)
-    (#const AF_INET6) -> do
-        port <- (#peek struct sockaddr_in6, sin6_port) p
-        flow <- (#peek struct sockaddr_in6, sin6_flowinfo) p
-        In6Addr addr <- (#peek struct sockaddr_in6, sin6_addr) p
-        scope <- (#peek struct sockaddr_in6, sin6_scope_id) p
-        return (SockAddrInet6 (PortNum port) flow addr scope)
-#endif
-#if defined(CAN_SOCKET_SUPPORT)
-    (#const AF_CAN) -> do
-        ifidx <- (#peek struct sockaddr_can, can_ifindex) p
-        return (SockAddrCan ifidx)
-#endif
-    _ -> throwIO $ userError $ "peekSockAddr: " ++ show family ++ " not supported on this platform."
-
-------------------------------------------------------------------------
-
--- | The raw network byte order number is read using host byte order.
--- Therefore on little-endian architectures the byte order is swapped. For
--- example @127.0.0.1@ is represented as @0x0100007f@ on little-endian hosts
--- and as @0x7f000001@ on big-endian hosts.
---
--- For direct manipulation prefer 'hostAddressToTuple' and
--- 'tupleToHostAddress'.
-type HostAddress = Word32
-
--- | Converts 'HostAddress' to representation-independent IPv4 quadruple.
--- For example for @127.0.0.1@ the function will return @(0x7f, 0, 0, 1)@
--- regardless of host endianness.
-hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)
-hostAddressToTuple ha' =
-    let ha = htonl ha'
-        byte i = fromIntegral (ha `shiftR` i) :: Word8
-    in (byte 24, byte 16, byte 8, byte 0)
-
--- | Converts IPv4 quadruple to 'HostAddress'.
-tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress
-tupleToHostAddress (b3, b2, b1, b0) =
-    let x `sl` i = fromIntegral x `shiftL` i :: Word32
-    in ntohl $ (b3 `sl` 24) .|. (b2 `sl` 16) .|. (b1 `sl` 8) .|. (b0 `sl` 0)
-
-#if defined(IPV6_SOCKET_SUPPORT)
--- | Independent of endianness. For example @::1@ is stored as @(0, 0, 0, 1)@.
---
--- For direct manipulation prefer 'hostAddress6ToTuple' and
--- 'tupleToHostAddress6'.
-type HostAddress6 = (Word32, Word32, Word32, Word32)
-
-hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16,
-                                        Word16, Word16, Word16, Word16)
-hostAddress6ToTuple (w3, w2, w1, w0) =
-    let high, low :: Word32 -> Word16
-        high w = fromIntegral (w `shiftR` 16)
-        low w = fromIntegral w
-    in (high w3, low w3, high w2, low w2, high w1, low w1, high w0, low w0)
-
-tupleToHostAddress6 :: (Word16, Word16, Word16, Word16,
-                        Word16, Word16, Word16, Word16) -> HostAddress6
-tupleToHostAddress6 (w7, w6, w5, w4, w3, w2, w1, w0) =
-    let add :: Word16 -> Word16 -> Word32
-        high `add` low = (fromIntegral high `shiftL` 16) .|. (fromIntegral low)
-    in (w7 `add` w6, w5 `add` w4, w3 `add` w2, w1 `add` w0)
-
--- The peek32 and poke32 functions work around the fact that the RFCs
--- don't require 32-bit-wide address fields to be present.  We can
--- only portably rely on an 8-bit field, s6_addr.
-
-s6_addr_offset :: Int
-s6_addr_offset = (#offset struct in6_addr, s6_addr)
-
-peek32 :: Ptr a -> Int -> IO Word32
-peek32 p i0 = do
-    let i' = i0 * 4
-        peekByte n = peekByteOff p (s6_addr_offset + i' + n) :: IO Word8
-        a `sl` i = fromIntegral a `shiftL` i
-    a0 <- peekByte 0
-    a1 <- peekByte 1
-    a2 <- peekByte 2
-    a3 <- peekByte 3
-    return ((a0 `sl` 24) .|. (a1 `sl` 16) .|. (a2 `sl` 8) .|. (a3 `sl` 0))
-
-poke32 :: Ptr a -> Int -> Word32 -> IO ()
-poke32 p i0 a = do
-    let i' = i0 * 4
-        pokeByte n = pokeByteOff p (s6_addr_offset + i' + n)
-        x `sr` i = fromIntegral (x `shiftR` i) :: Word8
-    pokeByte 0 (a `sr` 24)
-    pokeByte 1 (a `sr` 16)
-    pokeByte 2 (a `sr`  8)
-    pokeByte 3 (a `sr`  0)
-
--- | Private newtype proxy for the Storable instance. To avoid orphan instances.
-newtype In6Addr = In6Addr HostAddress6
-
-#if __GLASGOW_HASKELL__ < 800
-#let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
-#endif
-
-instance Storable In6Addr where
-    sizeOf _    = #const sizeof(struct in6_addr)
-    alignment _ = #alignment struct in6_addr
-
-    peek p = do
-        a <- peek32 p 0
-        b <- peek32 p 1
-        c <- peek32 p 2
-        d <- peek32 p 3
-        return $ In6Addr (a, b, c, d)
-
-    poke p (In6Addr (a, b, c, d)) = do
-        poke32 p 0 a
-        poke32 p 1 b
-        poke32 p 2 c
-        poke32 p 3 d
-#endif
-
-------------------------------------------------------------------------
--- Helper functions
-
-foreign import ccall unsafe "string.h" memset :: Ptr a -> CInt -> CSize -> IO ()
-
--- | Zero a structure.
-zeroMemory :: Ptr a -> CSize -> IO ()
-zeroMemory dest nbytes = memset dest 0 (fromIntegral nbytes)
diff --git a/java/Utils.java b/java/Utils.java
new file mode 100644
index 0000000..6dd9f0e
--- /dev/null
+++ b/java/Utils.java
@@ -0,0 +1,15 @@
+package eta.network;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+public class Utils {
+    public static String inet_ntoa(int bytes) throws UnknownHostException {
+        return InetAddress.getByAddress(new byte[]{
+                (byte)(bytes >>> 24),
+                (byte)(bytes >>> 16),
+                (byte)(bytes >>> 8),
+                (byte)bytes
+            }).toString().substring(1);
+    }
+}
diff --git a/network.cabal b/network.cabal
index c90c9b1..0b0a9c4 100644
--- a/network.cabal
+++ b/network.cabal
@@ -26,7 +26,7 @@ description:
   That is, get the module from either network < 2.6 or from
   network-uri >= 2.6.
 category:       Network
-build-type:     Configure
+build-type:     Simple
 cabal-version:  >=1.8
 extra-tmp-files:
   config.log config.status autom4te.cache network.buildinfo
@@ -45,39 +45,40 @@ tested-with:   GHC == 7.0.4, GHC == 7.4.2, GHC == 7.6.3, GHC == 7.8.4, GHC == 7.
 
 library
   exposed-modules:
-    Network
-    Network.BSD
+    -- Network
+    -- Network.BSD
     Network.Socket
-    Network.Socket.ByteString
-    Network.Socket.ByteString.Lazy
-    Network.Socket.Internal
+    -- Network.Socket.ByteString
+    -- Network.Socket.ByteString.Lazy
+    -- Network.Socket.Internal
   other-modules:
-    Network.Socket.ByteString.Internal
+    -- Network.Socket.ByteString.Internal
     Network.Socket.Types
 
-  if !os(windows)
-    other-modules:
-      Network.Socket.ByteString.IOVec
-      Network.Socket.ByteString.Lazy.Posix
-      Network.Socket.ByteString.MsgHdr
-  if os(windows)
-    other-modules:
-      Network.Socket.ByteString.Lazy.Windows
+  -- if !os(windows)
+  --   other-modules:
+  --     Network.Socket.ByteString.IOVec
+  --     Network.Socket.ByteString.Lazy.Posix
+  --     Network.Socket.ByteString.MsgHdr
+  -- if os(windows)
+  --   other-modules:
+  --     Network.Socket.ByteString.Lazy.Windows
 
   build-depends:
     base >= 3 && < 5,
     bytestring < 0.11
 
-  if !os(windows)
-    build-depends:
-      unix >= 2
+  -- if !os(windows)
+  --   build-depends:
+  --     unix >= 2
 
   extensions:
     CPP, DeriveDataTypeable, ForeignFunctionInterface, TypeSynonymInstances
-  include-dirs: include
-  includes: HsNet.h
-  install-includes: HsNet.h HsNetworkConfig.h
-  c-sources: cbits/HsNet.c
+  -- include-dirs: include
+  -- includes: HsNet.h
+  -- install-includes: HsNet.h HsNetworkConfig.h
+  -- c-sources: cbits/HsNet.c
+  java-sources: java/Utils.java
   ghc-options: -Wall -fwarn-tabs
 
 test-suite simple
-- 
2.7.4 (Apple Git-66)

